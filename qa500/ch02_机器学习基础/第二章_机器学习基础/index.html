



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="AI Wiki 是一个编程竞赛知识整合站点，提供有趣又实用的编程竞赛知识以及其他有帮助的内容，帮助广大编程竞赛爱好者更快更深入地学习编程竞赛">
      
      
        <link rel="canonical" href="https://hai5g.cn/aiwiki/qa500/ch02_机器学习基础/第二章_机器学习基础/">
      
      
        <meta name="author" content="AI Wiki Team">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.2.0">
    
    
      
        <title>第二章_机器学习基础 - AI Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/application.750b69bd.css">
      
        <link rel="stylesheet" href="../../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans:300,400,400i,700|Fira+Mono">
        <style>body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../../assets/fonts/material-icons.css">
    
      <link rel="manifest" href="../../../manifest.webmanifest">
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ah@1.5.0/han.min.css">
    
      <link rel="stylesheet" href="../../../_static/css/extra.css?v=11">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://hai5g.cn/aiwiki" title="AI Wiki" class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              AI Wiki
            </span>
            <span class="md-header-nav__topic">
              第二章_机器学习基础
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/myourdream/aiwiki/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    aiwiki
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../.." title="简介" class="md-tabs__link">
          简介
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../basic/" title="特征工程" class="md-tabs__link">
          特征工程
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../" title="深度学习500问" class="md-tabs__link md-tabs__link--active">
          深度学习500问
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../dp/" title="经典算法" class="md-tabs__link">
          经典算法
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../string/" title="集成学习算法" class="md-tabs__link">
          集成学习算法
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../math/" title="CNN" class="md-tabs__link">
          CNN
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../ds/" title="RNN" class="md-tabs__link">
          RNN
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../graph/" title="GAN" class="md-tabs__link">
          GAN
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../geometry/" title="计算机视觉" class="md-tabs__link">
          计算机视觉
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../misc/" title="NLP" class="md-tabs__link">
          NLP
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../misc/" title="推荐系统" class="md-tabs__link">
          推荐系统
        </a>
      
    </li>
  

      
        
      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://hai5g.cn/aiwiki" title="AI Wiki" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    AI Wiki
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/myourdream/aiwiki/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    aiwiki
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../.." title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/AI学习路线/" title="AI学习路线" class="md-nav__link">
      AI学习路线
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/mode/" title="AI 赛事与赛制" class="md-nav__link">
      AI 赛事与赛制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/icpc/" title="ICPC/CCPC 赛事与赛制" class="md-nav__link">
      ICPC/CCPC 赛事与赛制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/resources/" title="学习资源" class="md-nav__link">
      学习资源
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/common-mistakes/" title="常见错误" class="md-nav__link">
      常见错误
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/common-tricks/" title="常见技巧" class="md-nav__link">
      常见技巧
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/non-traditional/" title="非传统题" class="md-nav__link">
      非传统题
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-9" type="checkbox" id="nav-1-9">
    
    <label class="md-nav__link" for="nav-1-9">
      工具软件
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-9">
        工具软件
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/judgers/" title="评测工具" class="md-nav__link">
      评测工具
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/editors/" title="编辑工具" class="md-nav__link">
      编辑工具
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/wsl/" title="WSL (Windows 10)" class="md-nav__link">
      WSL (Windows 10)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/spj/" title="Special Judge" class="md-nav__link">
      Special Judge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-9-5" type="checkbox" id="nav-1-9-5">
    
    <label class="md-nav__link" for="nav-1-9-5">
      Testlib
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-9-5">
        Testlib
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/" title="Testlib 简介" class="md-nav__link">
      Testlib 简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/general/" title="通用" class="md-nav__link">
      通用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/generator/" title="Generator" class="md-nav__link">
      Generator
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/validator/" title="Validator" class="md-nav__link">
      Validator
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/interactor/" title="Interactor" class="md-nav__link">
      Interactor
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/testlib/checker/" title="Checker" class="md-nav__link">
      Checker
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/docker-deploy/" title="Docker 部署" class="md-nav__link">
      Docker 部署
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/about/" title="关于本项目" class="md-nav__link">
      关于本项目
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/faq/" title="F.A.Q." class="md-nav__link">
      F.A.Q.
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      特征工程
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        特征工程
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/" title="基础部分简介" class="md-nav__link">
      基础部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/enumerate/" title="枚举" class="md-nav__link">
      枚举
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/simulate/" title="模拟" class="md-nav__link">
      模拟
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/divide-and-conquer/" title="递归 & 分治" class="md-nav__link">
      递归 & 分治
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/greedy/" title="贪心" class="md-nav__link">
      贪心
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-6" type="checkbox" id="nav-2-6">
    
    <label class="md-nav__link" for="nav-2-6">
      排序
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-6">
        排序
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/sort-intro/" title="排序简介" class="md-nav__link">
      排序简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/selection-sort/" title="选择排序" class="md-nav__link">
      选择排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/bubble-sort/" title="冒泡排序" class="md-nav__link">
      冒泡排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/insertion-sort/" title="插入排序" class="md-nav__link">
      插入排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/bucket-sort/" title="计数排序" class="md-nav__link">
      计数排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/quick-sort/" title="快速排序" class="md-nav__link">
      快速排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/merge-sort/" title="归并排序" class="md-nav__link">
      归并排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/heap-sort/" title="堆排序" class="md-nav__link">
      堆排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/radix-sort/" title="基数排序" class="md-nav__link">
      基数排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/shell-sort/" title="希尔排序" class="md-nav__link">
      希尔排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/stl-sort/" title="排序相关 STL" class="md-nav__link">
      排序相关 STL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/use-of-sort/" title="排序应用" class="md-nav__link">
      排序应用
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/expression/" title="表达式求值" class="md-nav__link">
      表达式求值
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/binary/" title="二分" class="md-nav__link">
      二分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/construction/" title="构造" class="md-nav__link">
      构造
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/prefix-sum/" title="前缀和 & 差分" class="md-nav__link">
      前缀和 & 差分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../basic/file-operation/" title="文件操作" class="md-nav__link">
      文件操作
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      深度学习500问
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        深度学习500问
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../" title="简介" class="md-nav__link">
      简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../content/" title="目录" class="md-nav__link">
      目录
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch01_math/ch01_math/" title="第一章_数学基础" class="md-nav__link">
      第一章_数学基础
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        第二章_机器学习基础
      </label>
    
    <a href="./" title="第二章_机器学习基础" class="md-nav__link md-nav__link--active">
      第二章_机器学习基础
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#21" title="2.1 大话理解机器学习本质" class="md-nav__link">
    2.1 大话理解机器学习本质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22" title="2.2 各种常见算法图示" class="md-nav__link">
    2.2 各种常见算法图示
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" title="2.3 监督学习、非监督学习、半监督学习、弱监督学习？" class="md-nav__link">
    2.3 监督学习、非监督学习、半监督学习、弱监督学习？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" title="2.4 监督学习有哪些步骤" class="md-nav__link">
    2.4 监督学习有哪些步骤
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" title="2.5 多实例学习？" class="md-nav__link">
    2.5 多实例学习？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26" title="2.6 什么是神经网络？" class="md-nav__link">
    2.6 什么是神经网络？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" title="2.7 理解局部最优与全局最优" class="md-nav__link">
    2.7 理解局部最优与全局最优
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" title="2.8 分类算法" class="md-nav__link">
    2.8 分类算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#281" title="2.8.1 常用分类算法的优缺点？" class="md-nav__link">
    2.8.1 常用分类算法的优缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#282" title="2.8.2 分类算法的评估方法？" class="md-nav__link">
    2.8.2 分类算法的评估方法？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#283" title="2.8.3 正确率能很好的评估分类算法吗？" class="md-nav__link">
    2.8.3 正确率能很好的评估分类算法吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#284" title="2.8.4 什么样的分类器是最好的？" class="md-nav__link">
    2.8.4 什么样的分类器是最好的？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29" title="2.9 逻辑回归" class="md-nav__link">
    2.9 逻辑回归
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#291" title="2.9.1 回归划分" class="md-nav__link">
    2.9.1 回归划分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#292" title="2.9.2 逻辑回归适用性" class="md-nav__link">
    2.9.2 逻辑回归适用性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#293" title="2.9.3 逻辑回归与朴素贝叶斯有什么区别？" class="md-nav__link">
    2.9.3 逻辑回归与朴素贝叶斯有什么区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#294" title="2.9.4 线性回归与逻辑回归的区别？" class="md-nav__link">
    2.9.4 线性回归与逻辑回归的区别？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#210" title="2.10 代价函数" class="md-nav__link">
    2.10 代价函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2101" title="2.10.1 为什么需要代价函数？" class="md-nav__link">
    2.10.1 为什么需要代价函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2102" title="2.10.2 代价函数作用原理" class="md-nav__link">
    2.10.2 代价函数作用原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2103" title="2.10.3 为什么代价函数要非负？" class="md-nav__link">
    2.10.3 为什么代价函数要非负？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2104" title="2.10.4 常见代价函数？" class="md-nav__link">
    2.10.4 常见代价函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2105" title="2.10.5 为什么用交叉熵代替二次代价函数" class="md-nav__link">
    2.10.5 为什么用交叉熵代替二次代价函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#211" title="2.11 损失函数" class="md-nav__link">
    2.11 损失函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2111" title="2.11.1 什么是损失函数？" class="md-nav__link">
    2.11.1 什么是损失函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2112" title="2.11.2 常见的损失函数" class="md-nav__link">
    2.11.2 常见的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2113" title="2.11.3 逻辑回归为什么使用对数损失函数？" class="md-nav__link">
    2.11.3 逻辑回归为什么使用对数损失函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2114" title="2.11.4 对数损失函数是如何度量损失的？" class="md-nav__link">
    2.11.4 对数损失函数是如何度量损失的？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#212" title="2.12 梯度下降" class="md-nav__link">
    2.12 梯度下降
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2121" title="2.12.1 机器学习中为什么需要梯度下降？" class="md-nav__link">
    2.12.1 机器学习中为什么需要梯度下降？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2122" title="2.12.2 梯度下降法缺点？" class="md-nav__link">
    2.12.2 梯度下降法缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2123" title="2.12.3 梯度下降法直观理解？" class="md-nav__link">
    2.12.3 梯度下降法直观理解？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2124" title="2.12.4 梯度下降法算法描述" class="md-nav__link">
    2.12.4 梯度下降法算法描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2125" title="2.12.5 如何对梯度下降法进行调优？" class="md-nav__link">
    2.12.5 如何对梯度下降法进行调优？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2126" title="2.12.6 随机梯度和批量梯度区别？" class="md-nav__link">
    2.12.6 随机梯度和批量梯度区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2127" title="2.12.7 各种梯度下降法性能比较" class="md-nav__link">
    2.12.7 各种梯度下降法性能比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#213" title="2.13 计算图的导数计算？" class="md-nav__link">
    2.13 计算图的导数计算？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#214-lda" title="2.14 线性判别分析（LDA）" class="md-nav__link">
    2.14 线性判别分析（LDA）
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2141-lda" title="2.14.1 LDA思想总结" class="md-nav__link">
    2.14.1 LDA思想总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2142-lda" title="2.14.2 图解LDA核心思想" class="md-nav__link">
    2.14.2 图解LDA核心思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2143-lda" title="2.14.3 二类LDA算法原理？" class="md-nav__link">
    2.14.3 二类LDA算法原理？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2144-lda" title="2.14.4 LDA算法流程总结？" class="md-nav__link">
    2.14.4 LDA算法流程总结？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2145-ldapca" title="2.14.5 LDA和PCA区别？" class="md-nav__link">
    2.14.5 LDA和PCA区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2146-lda" title="2.14.6 LDA优缺点？" class="md-nav__link">
    2.14.6 LDA优缺点？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#215-pca" title="2.15  主成分分析（PCA）" class="md-nav__link">
    2.15  主成分分析（PCA）
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2151-pca" title="2.15.1 主成分分析（PCA）思想总结" class="md-nav__link">
    2.15.1 主成分分析（PCA）思想总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2152-pca" title="2.15.2 图解PCA核心思想" class="md-nav__link">
    2.15.2 图解PCA核心思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2153-pca" title="2.15.3 PCA算法推理" class="md-nav__link">
    2.15.3 PCA算法推理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2154-pca" title="2.15.4 PCA算法流程总结" class="md-nav__link">
    2.15.4 PCA算法流程总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2155-pca" title="2.15.5 PCA算法主要优缺点" class="md-nav__link">
    2.15.5 PCA算法主要优缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2156" title="2.15.6 降维的必要性及目的" class="md-nav__link">
    2.15.6 降维的必要性及目的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2157-kpcapca" title="2.15.7 KPCA与PCA的区别？" class="md-nav__link">
    2.15.7 KPCA与PCA的区别？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#216" title="2.16 模型评估" class="md-nav__link">
    2.16 模型评估
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2161" title="2.16.1 模型评估常用方法？" class="md-nav__link">
    2.16.1 模型评估常用方法？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2162" title="2.16.2 误差、偏差和方差有什么区别和联系？" class="md-nav__link">
    2.16.2 误差、偏差和方差有什么区别和联系？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2163" title="2.16.3 经验误差与泛化误差" class="md-nav__link">
    2.16.3 经验误差与泛化误差
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2164" title="2.16.4 图解欠拟合、过拟合" class="md-nav__link">
    2.16.4 图解欠拟合、过拟合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2165" title="2.16.5 如何解决过拟合与欠拟合？" class="md-nav__link">
    2.16.5 如何解决过拟合与欠拟合？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2166" title="2.16.6 交叉验证的主要作用" class="md-nav__link">
    2.16.6 交叉验证的主要作用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2167-k" title="2.16.7 理解k折交叉验证" class="md-nav__link">
    2.16.7 理解k折交叉验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2168" title="2.16.8 混淆矩阵" class="md-nav__link">
    2.16.8 混淆矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2169" title="2.16.9 错误率及精度" class="md-nav__link">
    2.16.9 错误率及精度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21610" title="2.16.10 查准率与查全率" class="md-nav__link">
    2.16.10 查准率与查全率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21611-rocauc" title="2.16.11 ROC与AUC" class="md-nav__link">
    2.16.11 ROC与AUC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21612-roc" title="2.16.12 如何画ROC曲线？" class="md-nav__link">
    2.16.12 如何画ROC曲线？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21613-tprfpr" title="2.16.13 如何计算TPR，FPR？" class="md-nav__link">
    2.16.13 如何计算TPR，FPR？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21614-auc" title="2.16.14 如何计算AUC？" class="md-nav__link">
    2.16.14 如何计算AUC？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21615-rocauc" title="2.16.15 为什么使用Roc和Auc评价分类器？" class="md-nav__link">
    2.16.15 为什么使用Roc和Auc评价分类器？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21616-auc" title="2.16.16 直观理解AUC" class="md-nav__link">
    2.16.16 直观理解AUC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21617" title="2.16.17 代价敏感错误率与代价曲线" class="md-nav__link">
    2.16.17 代价敏感错误率与代价曲线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21618" title="2.16.18 模型有哪些比较检验方法" class="md-nav__link">
    2.16.18 模型有哪些比较检验方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21619" title="2.16.19 为什么使用标准差？" class="md-nav__link">
    2.16.19 为什么使用标准差？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21620" title="2.16.20 类别不平衡产生原因？" class="md-nav__link">
    2.16.20 类别不平衡产生原因？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21621" title="2.16.21 常见的类别不平衡问题解决方法" class="md-nav__link">
    2.16.21 常见的类别不平衡问题解决方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#217" title="2.17 决策树" class="md-nav__link">
    2.17 决策树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2171" title="2.17.1 决策树的基本原理" class="md-nav__link">
    2.17.1 决策树的基本原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2172" title="2.17.2 决策树的三要素？" class="md-nav__link">
    2.17.2 决策树的三要素？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2173" title="2.17.3 决策树学习基本算法" class="md-nav__link">
    2.17.3 决策树学习基本算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2174" title="2.17.4 决策树算法优缺点" class="md-nav__link">
    2.17.4 决策树算法优缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2175" title="2.17.5 熵的概念以及理解" class="md-nav__link">
    2.17.5 熵的概念以及理解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2176" title="2.17.6 信息增益的理解" class="md-nav__link">
    2.17.6 信息增益的理解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2177" title="2.17.7 剪枝处理的作用及策略？" class="md-nav__link">
    2.17.7 剪枝处理的作用及策略？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#218" title="2.18 支持向量机" class="md-nav__link">
    2.18 支持向量机
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2181" title="2.18.1 什么是支持向量机" class="md-nav__link">
    2.18.1 什么是支持向量机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2182" title="2.18.2 支持向量机能解决哪些问题？" class="md-nav__link">
    2.18.2 支持向量机能解决哪些问题？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2183" title="2.18.3 核函数特点及其作用？" class="md-nav__link">
    2.18.3 核函数特点及其作用？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2184-svm" title="2.18.4 SVM为什么引入对偶问题？" class="md-nav__link">
    2.18.4 SVM为什么引入对偶问题？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2185-svm" title="2.18.5 如何理解SVM中的对偶问题" class="md-nav__link">
    2.18.5 如何理解SVM中的对偶问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2187" title="2.18.7 常见的核函数有哪些？" class="md-nav__link">
    2.18.7 常见的核函数有哪些？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2189-svm" title="2.18.9 SVM主要特点？" class="md-nav__link">
    2.18.9 SVM主要特点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21810-svm" title="2.18.10 SVM主要缺点？" class="md-nav__link">
    2.18.10 SVM主要缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21811-svm" title="2.18.11 逻辑回归与SVM的异同" class="md-nav__link">
    2.18.11 逻辑回归与SVM的异同
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#219" title="2.19 贝叶斯分类器" class="md-nav__link">
    2.19 贝叶斯分类器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2191" title="2.19.1 图解极大似然估计" class="md-nav__link">
    2.19.1 图解极大似然估计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2192" title="2.19.2 极大似然估计原理" class="md-nav__link">
    2.19.2 极大似然估计原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2193" title="2.19.3 贝叶斯分类器基本原理" class="md-nav__link">
    2.19.3 贝叶斯分类器基本原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2194" title="2.19.4 朴素贝叶斯分类器" class="md-nav__link">
    2.19.4 朴素贝叶斯分类器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2195" title="2.19.5 举例理解朴素贝叶斯分类器" class="md-nav__link">
    2.19.5 举例理解朴素贝叶斯分类器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2196" title="2.19.6 半朴素贝叶斯分类器" class="md-nav__link">
    2.19.6 半朴素贝叶斯分类器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#220-em" title="2.20 EM算法" class="md-nav__link">
    2.20 EM算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2201-em" title="2.20.1 EM算法基本思想" class="md-nav__link">
    2.20.1 EM算法基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2202-em" title="2.20.2 EM算法推导" class="md-nav__link">
    2.20.2 EM算法推导
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2203-em" title="2.20.3 图解EM算法" class="md-nav__link">
    2.20.3 图解EM算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2204-em" title="2.20.4 EM算法流程" class="md-nav__link">
    2.20.4 EM算法流程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#221" title="2.21 降维和聚类" class="md-nav__link">
    2.21 降维和聚类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2211" title="2.21.1 图解为什么会产生“维数灾难”？" class="md-nav__link">
    2.21.1 图解为什么会产生“维数灾难”？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2212" title="2.21.2 怎样避免维数灾难" class="md-nav__link">
    2.21.2 怎样避免维数灾难
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2213" title="2.21.3 聚类和降维有什么区别与联系？" class="md-nav__link">
    2.21.3 聚类和降维有什么区别与联系？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2214" title="2.21.4 有哪些聚类算法优劣衡量标准" class="md-nav__link">
    2.21.4 有哪些聚类算法优劣衡量标准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2215" title="2.21.5 聚类和分类有什么区别？" class="md-nav__link">
    2.21.5 聚类和分类有什么区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2216" title="2.21.6 不同聚类算法特点性能比较" class="md-nav__link">
    2.21.6 不同聚类算法特点性能比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2217" title="2.21.7 四种常用聚类方法之比较" class="md-nav__link">
    2.21.7 四种常用聚类方法之比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2218-k-means" title="2.21.8 k-means聚类算法" class="md-nav__link">
    2.21.8 k-means聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2219" title="2.21.9 层次聚类算法" class="md-nav__link">
    2.21.9 层次聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22110-som" title="2.21.10 SOM聚类算法" class="md-nav__link">
    2.21.10 SOM聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22111-fcm" title="2.21.11 FCM聚类算法" class="md-nav__link">
    2.21.11 FCM聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22112" title="2.21.12 四种聚类算法试验" class="md-nav__link">
    2.21.12 四种聚类算法试验
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#222-gbdt" title="2.22 GBDT和随机森林的区别" class="md-nav__link">
    2.22 GBDT和随机森林的区别
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#223-one-hot-encodeing" title="2.23 理解 One Hot Encodeing 原理及作用？" class="md-nav__link">
    2.23 理解 One Hot Encodeing 原理及作用？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#224" title="2.24 大数据与深度学习之间的关系" class="md-nav__link">
    2.24 大数据与深度学习之间的关系
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="参考文献" class="md-nav__link">
    参考文献
  </a>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch03_深度学习基础/第三章_深度学习基础/" title="第三章_深度学习基础" class="md-nav__link">
      第三章_深度学习基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch04_经典网络/第四章_经典网络/" title="第四章_经典网络" class="md-nav__link">
      第四章_经典网络
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch05_卷积神经网络(CNN)/第五章 卷积神经网络（CNN）/" title="第五章 卷积神经网络（CNN）" class="md-nav__link">
      第五章 卷积神经网络（CNN）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch06_循环神经网络(RNN)/第六章_循环神经网络(RNN)/" title="第六章_循环神经网络(RNN)" class="md-nav__link">
      第六章_循环神经网络(RNN)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch07_生成对抗网络(GAN)/ch7/" title="第七章_生成对抗网络(GAN)" class="md-nav__link">
      第七章_生成对抗网络(GAN)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch08_目标检测/第八章_目标检测/" title="第八章_目标检测" class="md-nav__link">
      第八章_目标检测
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch09_图像分割/第九章_图像分割/" title="第九章_图像分割" class="md-nav__link">
      第九章_图像分割
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch10_强化学习/第十章_强化学习/" title="第十章_强化学习" class="md-nav__link">
      第十章_强化学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch11_迁移学习/第十一章_迁移学习/" title="第十一章_迁移学习" class="md-nav__link">
      第十一章_迁移学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch12_网络搭建及训练/第十二章_网络搭建及训练/" title="第十二章_网络搭建及训练" class="md-nav__link">
      第十二章_网络搭建及训练
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch13_优化算法/第十三章_优化算法/" title="第十三章_优化算法" class="md-nav__link">
      第十三章_优化算法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch14_超参数调整/第十四章_超参数调整/" title="第十四章_超参数调整" class="md-nav__link">
      第十四章_超参数调整
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch15_GPU和框架选型/第十五章_异构运算、GPU及框架选型/" title="第十五章_异构运算、GPU及框架选型" class="md-nav__link">
      第十五章_异构运算、GPU及框架选型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch16_自然语言处理(NLP)/第十六章_NLP/" title="第十六章_NLP" class="md-nav__link">
      第十六章_NLP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch17_模型压缩、加速及移动端部署/第十七章_模型压缩、加速及移动端部署/" title="第十七章_模型压缩、加速及移动端部署" class="md-nav__link">
      第十七章_模型压缩、加速及移动端部署
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch18_后端架构选型、离线及实时计算/第十八章_后端架构选型、离线及实时计算/" title="第十八章_后端架构选型、离线及实时计算" class="md-nav__link">
      第十八章_后端架构选型、离线及实时计算
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ch18_后端架构选型及应用场景/第十八章_后端架构选型及应用场景/" title="第十八章_后端架构选型及应用场景" class="md-nav__link">
      第十八章_后端架构选型及应用场景
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      经典算法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        经典算法
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/" title="动态规划部分简介" class="md-nav__link">
      动态规划部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/memo/" title="记忆化搜索" class="md-nav__link">
      记忆化搜索
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/knapsack/" title="背包 DP" class="md-nav__link">
      背包 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/interval/" title="区间 DP" class="md-nav__link">
      区间 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/dag/" title="DAG 上的 DP" class="md-nav__link">
      DAG 上的 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/tree/" title="树形 DP" class="md-nav__link">
      树形 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/state/" title="状压 DP" class="md-nav__link">
      状压 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/number/" title="数位 DP" class="md-nav__link">
      数位 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/plug/" title="插头 DP" class="md-nav__link">
      插头 DP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4-10" type="checkbox" id="nav-4-10">
    
    <label class="md-nav__link" for="nav-4-10">
      DP 优化
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-4-10">
        DP 优化
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/optimizations/binary-knapsack/" title="二进制分组解多重背包" class="md-nav__link">
      二进制分组解多重背包
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/optimizations/monotonous-queue-stack/" title="单调队列/单调栈优化" class="md-nav__link">
      单调队列/单调栈优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/optimizations/convex-hull-optimization/" title="斜率优化" class="md-nav__link">
      斜率优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/optimizations/knuth-yao-quadrangle-inequality/" title="四边形不等式优化" class="md-nav__link">
      四边形不等式优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/optimizations/state-optimization/" title="状态设计优化" class="md-nav__link">
      状态设计优化
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dp/misc/" title="其它 DP 方法" class="md-nav__link">
      其它 DP 方法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      集成学习算法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        集成学习算法
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/" title="字符串部分简介" class="md-nav__link">
      字符串部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/lib-func/" title="标准库" class="md-nav__link">
      标准库
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/match/" title="字符串匹配" class="md-nav__link">
      字符串匹配
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/hash/" title="哈希" class="md-nav__link">
      哈希
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/prefix-function/" title="前缀函数与 KMP 算法" class="md-nav__link">
      前缀函数与 KMP 算法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/trie/" title="字典树 (Trie)" class="md-nav__link">
      字典树 (Trie)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/pam/" title="回文自动机" class="md-nav__link">
      回文自动机
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/sa/" title="后缀数组 (SA)" class="md-nav__link">
      后缀数组 (SA)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/ac-automaton/" title="AC 自动机" class="md-nav__link">
      AC 自动机
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/sam/" title="后缀自动机 (SAM)" class="md-nav__link">
      后缀自动机 (SAM)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/suffix-tree/" title="后缀树" class="md-nav__link">
      后缀树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/manacher/" title="Manacher" class="md-nav__link">
      Manacher
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/minimal-string/" title="最小表示法" class="md-nav__link">
      最小表示法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../string/z-function/" title="Z 函数（扩展 KMP）" class="md-nav__link">
      Z 函数（扩展 KMP）
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      CNN
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        CNN
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/" title="数学部分简介" class="md-nav__link">
      数学部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/base/" title="进制" class="md-nav__link">
      进制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/bit/" title="位运算" class="md-nav__link">
      位运算
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/bignum/" title="高精度" class="md-nav__link">
      高精度
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/quick-pow/" title="快速幂" class="md-nav__link">
      快速幂
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-6" type="checkbox" id="nav-6-6">
    
    <label class="md-nav__link" for="nav-6-6">
      整除及其性质
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-6">
        整除及其性质
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/prime/" title="素数" class="md-nav__link">
      素数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/gcd/" title="最大公约数" class="md-nav__link">
      最大公约数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/euler/" title="欧拉函数" class="md-nav__link">
      欧拉函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/sieve/" title="筛法" class="md-nav__link">
      筛法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/fermat/" title="费马小定理" class="md-nav__link">
      费马小定理
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-7" type="checkbox" id="nav-6-7">
    
    <label class="md-nav__link" for="nav-6-7">
      同余方程相关
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-7">
        同余方程相关
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/bezouts/" title="裴蜀定理" class="md-nav__link">
      裴蜀定理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/inverse/" title="乘法逆元" class="md-nav__link">
      乘法逆元
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/linear-equation/" title="线性同余方程" class="md-nav__link">
      线性同余方程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/crt/" title="中国剩余定理" class="md-nav__link">
      中国剩余定理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/bsgs/" title="BSGS" class="md-nav__link">
      BSGS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/primitive-root/" title="原根" class="md-nav__link">
      原根
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-8" type="checkbox" id="nav-6-8">
    
    <label class="md-nav__link" for="nav-6-8">
      线性代数
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-8">
        线性代数
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/matrix/" title="矩阵" class="md-nav__link">
      矩阵
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/gauss/" title="高斯消元" class="md-nav__link">
      高斯消元
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/basis/" title="线性基" class="md-nav__link">
      线性基
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/complex/" title="复数" class="md-nav__link">
      复数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/dictionary/" title="分段打表" class="md-nav__link">
      分段打表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-11" type="checkbox" id="nav-6-11">
    
    <label class="md-nav__link" for="nav-6-11">
      数论函数相关
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-11">
        数论函数相关
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/mobius/" title="莫比乌斯反演" class="md-nav__link">
      莫比乌斯反演
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/du-sieves/" title="杜教筛" class="md-nav__link">
      杜教筛
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-12" type="checkbox" id="nav-6-12">
    
    <label class="md-nav__link" for="nav-6-12">
      多项式
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-12">
        多项式
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/intro/" title="多项式部分简介" class="md-nav__link">
      多项式部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/lagrange-poly/" title="拉格朗日插值" class="md-nav__link">
      拉格朗日插值
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/fft/" title="快速傅里叶变换" class="md-nav__link">
      快速傅里叶变换
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/ntt/" title="快速数论变换" class="md-nav__link">
      快速数论变换
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/fwt/" title="快速沃尔什变换" class="md-nav__link">
      快速沃尔什变换
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/inv/" title="多项式求逆" class="md-nav__link">
      多项式求逆
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/sqrt/" title="多项式开方" class="md-nav__link">
      多项式开方
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/div-mod/" title="多项式除法|取模" class="md-nav__link">
      多项式除法|取模
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/ln-exp/" title="多项式对数函数|指数函数" class="md-nav__link">
      多项式对数函数|指数函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/newton/" title="多项式牛顿迭代" class="md-nav__link">
      多项式牛顿迭代
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/multipoint-eval-interpolation/" title="多项式多点求值|快速插值" class="md-nav__link">
      多项式多点求值|快速插值
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/tri-func/" title="多项式三角函数" class="md-nav__link">
      多项式三角函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/poly/inv-tri-func/" title="多项式反三角函数" class="md-nav__link">
      多项式反三角函数
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-13" type="checkbox" id="nav-6-13">
    
    <label class="md-nav__link" for="nav-6-13">
      组合数学
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-13">
        组合数学
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/combination/" title="排列组合" class="md-nav__link">
      排列组合
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/catalan/" title="卡特兰数" class="md-nav__link">
      卡特兰数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/stirling/" title="斯特林数" class="md-nav__link">
      斯特林数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/cantor/" title="康托展开" class="md-nav__link">
      康托展开
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/inclusion-exclusion-principle/" title="容斥原理" class="md-nav__link">
      容斥原理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/drawer-principle/" title="抽屉原理" class="md-nav__link">
      抽屉原理
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/expectation/" title="概率 & 期望" class="md-nav__link">
      概率 & 期望
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/permutation-group/" title="置换群" class="md-nav__link">
      置换群
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/integral/" title="数值积分" class="md-nav__link">
      数值积分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/linear-programming/" title="线性规划" class="md-nav__link">
      线性规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/game-theory/" title="博弈论" class="md-nav__link">
      博弈论
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../math/misc/" title="杂项" class="md-nav__link">
      杂项
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      RNN
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        RNN
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/" title="数据结构部分简介" class="md-nav__link">
      数据结构部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-2" type="checkbox" id="nav-7-2">
    
    <label class="md-nav__link" for="nav-7-2">
      STL
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-2">
        STL
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stl/" title="STL 简介" class="md-nav__link">
      STL 简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stl/vector/" title="vector" class="md-nav__link">
      vector
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stl/priority_queue/" title="priority_queue" class="md-nav__link">
      priority_queue
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stl/map/" title="map" class="md-nav__link">
      map
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stl/bitset/" title="bitset" class="md-nav__link">
      bitset
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-3" type="checkbox" id="nav-7-3">
    
    <label class="md-nav__link" for="nav-7-3">
      pb_ds
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-3">
        pb_ds
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/pb-ds/" title="pb_ds 简介" class="md-nav__link">
      pb_ds 简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/pb-ds/priority-queue/" title="__gnu_pbds::priority_queue" class="md-nav__link">
      __gnu_pbds::priority_queue
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/stack/" title="栈" class="md-nav__link">
      栈
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/queue/" title="队列" class="md-nav__link">
      队列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/linked-list/" title="链表" class="md-nav__link">
      链表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/hash/" title="哈希表" class="md-nav__link">
      哈希表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/dsu/" title="并查集" class="md-nav__link">
      并查集
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-9" type="checkbox" id="nav-7-9">
    
    <label class="md-nav__link" for="nav-7-9">
      堆
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-9">
        堆
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/heap/" title="堆简介" class="md-nav__link">
      堆简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/binary-heap/" title="二叉堆" class="md-nav__link">
      二叉堆
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/pairing-heap/" title="配对堆" class="md-nav__link">
      配对堆
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-10" type="checkbox" id="nav-7-10">
    
    <label class="md-nav__link" for="nav-7-10">
      块状数据结构
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-10">
        块状数据结构
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/square-root-decomposition/" title="分块思想" class="md-nav__link">
      分块思想
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/block-list/" title="块状链表" class="md-nav__link">
      块状链表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/block-array/" title="块状数组" class="md-nav__link">
      块状数组
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/tree-decompose/" title="树分块" class="md-nav__link">
      树分块
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/monotonous-stack/" title="单调栈" class="md-nav__link">
      单调栈
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/monotonous-queue/" title="单调队列" class="md-nav__link">
      单调队列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/sparse-table/" title="倍增" class="md-nav__link">
      倍增
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/bit/" title="树状数组" class="md-nav__link">
      树状数组
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/segment/" title="线段树" class="md-nav__link">
      线段树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/dividing/" title="划分树" class="md-nav__link">
      划分树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-17" type="checkbox" id="nav-7-17">
    
    <label class="md-nav__link" for="nav-7-17">
      平衡树
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-17">
        平衡树
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/bst/" title="二叉搜索树简介" class="md-nav__link">
      二叉搜索树简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/treap/" title="Treap" class="md-nav__link">
      Treap
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/splay/" title="Splay" class="md-nav__link">
      Splay
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/wblt/" title="WBLT" class="md-nav__link">
      WBLT
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/sbt/" title="Size Balanced Tree" class="md-nav__link">
      Size Balanced Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/avl/" title="AVL 树" class="md-nav__link">
      AVL 树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/scapegoat/" title="替罪羊树" class="md-nav__link">
      替罪羊树
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-18" type="checkbox" id="nav-7-18">
    
    <label class="md-nav__link" for="nav-7-18">
      树套树
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-18">
        树套树
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/seg-in-seg/" title="线段树套线段树" class="md-nav__link">
      线段树套线段树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/seg-in-balanced/" title="平衡树套线段树" class="md-nav__link">
      平衡树套线段树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/balanced-in-seg/" title="线段树套平衡树" class="md-nav__link">
      线段树套平衡树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent-in-bit/" title="树状数组套主席树" class="md-nav__link">
      树状数组套主席树
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/k-dtree/" title="K-Dtree" class="md-nav__link">
      K-Dtree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-20" type="checkbox" id="nav-7-20">
    
    <label class="md-nav__link" for="nav-7-20">
      可持久化数据结构
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-20">
        可持久化数据结构
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent/" title="可持久化数据结构简介" class="md-nav__link">
      可持久化数据结构简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent-seg/" title="可持久化线段树" class="md-nav__link">
      可持久化线段树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent-block-array/" title="可持久化块状数组" class="md-nav__link">
      可持久化块状数组
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent-balanced/" title="可持久化平衡树" class="md-nav__link">
      可持久化平衡树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/persistent-trie/" title="可持久化字典树" class="md-nav__link">
      可持久化字典树
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/odt/" title="珂朵莉树" class="md-nav__link">
      珂朵莉树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/lct/" title="Link Cut Tree" class="md-nav__link">
      Link Cut Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../ds/ett/" title="Euler Tour Tree" class="md-nav__link">
      Euler Tour Tree
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      GAN
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        GAN
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/" title="图论部分简介" class="md-nav__link">
      图论部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/basic/" title="图论基础" class="md-nav__link">
      图论基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/traverse/" title="图的遍历" class="md-nav__link">
      图的遍历
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8-4" type="checkbox" id="nav-8-4">
    
    <label class="md-nav__link" for="nav-8-4">
      树上问题
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-8-4">
        树上问题
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/tree-basic/" title="树基础" class="md-nav__link">
      树基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/lca/" title="最近公共祖先" class="md-nav__link">
      最近公共祖先
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/dfs-order/" title="DFS 序" class="md-nav__link">
      DFS 序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/tree-misc/" title="树的其他问题" class="md-nav__link">
      树的其他问题
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/tree-hash/" title="树哈希" class="md-nav__link">
      树哈希
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/heavy-light-decomposition/" title="树链剖分" class="md-nav__link">
      树链剖分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/tree-divide/" title="树分治" class="md-nav__link">
      树分治
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/dynamic-tree-divide/" title="动态树分治" class="md-nav__link">
      动态树分治
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/virtual-tree/" title="虚树" class="md-nav__link">
      虚树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/dsu-on-tree/" title="树上启发式合并" class="md-nav__link">
      树上启发式合并
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/matrix-tree/" title="矩阵树定理" class="md-nav__link">
      矩阵树定理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/dag/" title="有向无环图" class="md-nav__link">
      有向无环图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/topo/" title="拓扑排序" class="md-nav__link">
      拓扑排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/mst/" title="最小生成树" class="md-nav__link">
      最小生成树
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/mdst/" title="最小树形图" class="md-nav__link">
      最小树形图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/shortest-path/" title="最短路" class="md-nav__link">
      最短路
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/differential-constraints/" title="差分约束" class="md-nav__link">
      差分约束
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/kth-path/" title="k 短路" class="md-nav__link">
      k 短路
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8-13" type="checkbox" id="nav-8-13">
    
    <label class="md-nav__link" for="nav-8-13">
      连通性相关
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-8-13">
        连通性相关
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/scc/" title="强连通分量" class="md-nav__link">
      强连通分量
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/bcc/" title="双连通分量" class="md-nav__link">
      双连通分量
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/bridge/" title="割点和桥" class="md-nav__link">
      割点和桥
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/2-sat/" title="2-SAT" class="md-nav__link">
      2-SAT
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/euler/" title="欧拉图" class="md-nav__link">
      欧拉图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/hamilton/" title="哈密顿图" class="md-nav__link">
      哈密顿图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/bi-graph/" title="二分图" class="md-nav__link">
      二分图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/min-circle/" title="最小环" class="md-nav__link">
      最小环
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/planar/" title="平面图" class="md-nav__link">
      平面图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/color/" title="图的着色" class="md-nav__link">
      图的着色
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8-20" type="checkbox" id="nav-8-20">
    
    <label class="md-nav__link" for="nav-8-20">
      网络流
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-8-20">
        网络流
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/" title="网络流简介" class="md-nav__link">
      网络流简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/node/" title="拆点" class="md-nav__link">
      拆点
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/max-flow/" title="最大流" class="md-nav__link">
      最大流
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/min-cut/" title="最小割" class="md-nav__link">
      最小割
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/min-cost/" title="费用流" class="md-nav__link">
      费用流
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/flow/bound/" title="上下界网络流" class="md-nav__link">
      上下界网络流
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../graph/misc/" title="图论杂项" class="md-nav__link">
      图论杂项
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9">
    
    <label class="md-nav__link" for="nav-9">
      计算机视觉
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-9">
        计算机视觉
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/" title="计算几何部分简介" class="md-nav__link">
      计算几何部分简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/2d/" title="二维计算几何基础" class="md-nav__link">
      二维计算几何基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/3d/" title="三维计算几何基础" class="md-nav__link">
      三维计算几何基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/distance/" title="距离" class="md-nav__link">
      距离
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/pick/" title="Pick 定理" class="md-nav__link">
      Pick 定理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/triangulation/" title="三角剖分" class="md-nav__link">
      三角剖分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/convex-hull/" title="凸包" class="md-nav__link">
      凸包
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/scanning/" title="扫描线" class="md-nav__link">
      扫描线
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/rotating-calipers/" title="旋转卡壳" class="md-nav__link">
      旋转卡壳
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/half-plane-intersection/" title="半平面交" class="md-nav__link">
      半平面交
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/nearest-points/" title="平面最近点对" class="md-nav__link">
      平面最近点对
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../geometry/magic/" title="计算几何杂项" class="md-nav__link">
      计算几何杂项
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10" type="checkbox" id="nav-10">
    
    <label class="md-nav__link" for="nav-10">
      NLP
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-10">
        NLP
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/" title="杂项简介" class="md-nav__link">
      杂项简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/io/" title="读入、输出优化" class="md-nav__link">
      读入、输出优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/complexity/" title="复杂度" class="md-nav__link">
      复杂度
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/discrete/" title="离散化" class="md-nav__link">
      离散化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10-5" type="checkbox" id="nav-10-5">
    
    <label class="md-nav__link" for="nav-10-5">
      离线算法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-10-5">
        离线算法
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/offline/" title="离线算法简介" class="md-nav__link">
      离线算法简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/cdq-divide/" title="CDQ 分治" class="md-nav__link">
      CDQ 分治
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/mo-algo/" title="莫队算法" class="md-nav__link">
      莫队算法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/fractional-programming/" title="分数规划" class="md-nav__link">
      分数规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10-7" type="checkbox" id="nav-10-7">
    
    <label class="md-nav__link" for="nav-10-7">
      随机化
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-10-7">
        随机化
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/random/" title="随机函数" class="md-nav__link">
      随机函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/hill-climbing/" title="爬山算法" class="md-nav__link">
      爬山算法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/simulated-annealing/" title="模拟退火" class="md-nav__link">
      模拟退火
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/random-incremental/" title="随机增量法" class="md-nav__link">
      随机增量法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/largest-matrix/" title="悬线法" class="md-nav__link">
      悬线法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/cc-basic/" title="计算理论基础" class="md-nav__link">
      计算理论基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/endianness/" title="字节顺序" class="md-nav__link">
      字节顺序
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11" type="checkbox" id="nav-11">
    
    <label class="md-nav__link" for="nav-11">
      推荐系统
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-11">
        推荐系统
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/" title="杂项简介" class="md-nav__link">
      杂项简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/io/" title="读入、输出优化" class="md-nav__link">
      读入、输出优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/complexity/" title="复杂度" class="md-nav__link">
      复杂度
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/discrete/" title="离散化" class="md-nav__link">
      离散化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11-5" type="checkbox" id="nav-11-5">
    
    <label class="md-nav__link" for="nav-11-5">
      离线算法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-11-5">
        离线算法
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/offline/" title="离线算法简介" class="md-nav__link">
      离线算法简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/cdq-divide/" title="CDQ 分治" class="md-nav__link">
      CDQ 分治
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/mo-algo/" title="莫队算法" class="md-nav__link">
      莫队算法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/fractional-programming/" title="分数规划" class="md-nav__link">
      分数规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11-7" type="checkbox" id="nav-11-7">
    
    <label class="md-nav__link" for="nav-11-7">
      随机化
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-11-7">
        随机化
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/random/" title="随机函数" class="md-nav__link">
      随机函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/hill-climbing/" title="爬山算法" class="md-nav__link">
      爬山算法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/simulated-annealing/" title="模拟退火" class="md-nav__link">
      模拟退火
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/random-incremental/" title="随机增量法" class="md-nav__link">
      随机增量法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/largest-matrix/" title="悬线法" class="md-nav__link">
      悬线法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/cc-basic/" title="计算理论基础" class="md-nav__link">
      计算理论基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../misc/endianness/" title="字节顺序" class="md-nav__link">
      字节顺序
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#21" title="2.1 大话理解机器学习本质" class="md-nav__link">
    2.1 大话理解机器学习本质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22" title="2.2 各种常见算法图示" class="md-nav__link">
    2.2 各种常见算法图示
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" title="2.3 监督学习、非监督学习、半监督学习、弱监督学习？" class="md-nav__link">
    2.3 监督学习、非监督学习、半监督学习、弱监督学习？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" title="2.4 监督学习有哪些步骤" class="md-nav__link">
    2.4 监督学习有哪些步骤
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" title="2.5 多实例学习？" class="md-nav__link">
    2.5 多实例学习？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26" title="2.6 什么是神经网络？" class="md-nav__link">
    2.6 什么是神经网络？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" title="2.7 理解局部最优与全局最优" class="md-nav__link">
    2.7 理解局部最优与全局最优
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" title="2.8 分类算法" class="md-nav__link">
    2.8 分类算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#281" title="2.8.1 常用分类算法的优缺点？" class="md-nav__link">
    2.8.1 常用分类算法的优缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#282" title="2.8.2 分类算法的评估方法？" class="md-nav__link">
    2.8.2 分类算法的评估方法？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#283" title="2.8.3 正确率能很好的评估分类算法吗？" class="md-nav__link">
    2.8.3 正确率能很好的评估分类算法吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#284" title="2.8.4 什么样的分类器是最好的？" class="md-nav__link">
    2.8.4 什么样的分类器是最好的？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29" title="2.9 逻辑回归" class="md-nav__link">
    2.9 逻辑回归
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#291" title="2.9.1 回归划分" class="md-nav__link">
    2.9.1 回归划分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#292" title="2.9.2 逻辑回归适用性" class="md-nav__link">
    2.9.2 逻辑回归适用性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#293" title="2.9.3 逻辑回归与朴素贝叶斯有什么区别？" class="md-nav__link">
    2.9.3 逻辑回归与朴素贝叶斯有什么区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#294" title="2.9.4 线性回归与逻辑回归的区别？" class="md-nav__link">
    2.9.4 线性回归与逻辑回归的区别？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#210" title="2.10 代价函数" class="md-nav__link">
    2.10 代价函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2101" title="2.10.1 为什么需要代价函数？" class="md-nav__link">
    2.10.1 为什么需要代价函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2102" title="2.10.2 代价函数作用原理" class="md-nav__link">
    2.10.2 代价函数作用原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2103" title="2.10.3 为什么代价函数要非负？" class="md-nav__link">
    2.10.3 为什么代价函数要非负？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2104" title="2.10.4 常见代价函数？" class="md-nav__link">
    2.10.4 常见代价函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2105" title="2.10.5 为什么用交叉熵代替二次代价函数" class="md-nav__link">
    2.10.5 为什么用交叉熵代替二次代价函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#211" title="2.11 损失函数" class="md-nav__link">
    2.11 损失函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2111" title="2.11.1 什么是损失函数？" class="md-nav__link">
    2.11.1 什么是损失函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2112" title="2.11.2 常见的损失函数" class="md-nav__link">
    2.11.2 常见的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2113" title="2.11.3 逻辑回归为什么使用对数损失函数？" class="md-nav__link">
    2.11.3 逻辑回归为什么使用对数损失函数？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2114" title="2.11.4 对数损失函数是如何度量损失的？" class="md-nav__link">
    2.11.4 对数损失函数是如何度量损失的？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#212" title="2.12 梯度下降" class="md-nav__link">
    2.12 梯度下降
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2121" title="2.12.1 机器学习中为什么需要梯度下降？" class="md-nav__link">
    2.12.1 机器学习中为什么需要梯度下降？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2122" title="2.12.2 梯度下降法缺点？" class="md-nav__link">
    2.12.2 梯度下降法缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2123" title="2.12.3 梯度下降法直观理解？" class="md-nav__link">
    2.12.3 梯度下降法直观理解？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2124" title="2.12.4 梯度下降法算法描述" class="md-nav__link">
    2.12.4 梯度下降法算法描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2125" title="2.12.5 如何对梯度下降法进行调优？" class="md-nav__link">
    2.12.5 如何对梯度下降法进行调优？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2126" title="2.12.6 随机梯度和批量梯度区别？" class="md-nav__link">
    2.12.6 随机梯度和批量梯度区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2127" title="2.12.7 各种梯度下降法性能比较" class="md-nav__link">
    2.12.7 各种梯度下降法性能比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#213" title="2.13 计算图的导数计算？" class="md-nav__link">
    2.13 计算图的导数计算？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#214-lda" title="2.14 线性判别分析（LDA）" class="md-nav__link">
    2.14 线性判别分析（LDA）
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2141-lda" title="2.14.1 LDA思想总结" class="md-nav__link">
    2.14.1 LDA思想总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2142-lda" title="2.14.2 图解LDA核心思想" class="md-nav__link">
    2.14.2 图解LDA核心思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2143-lda" title="2.14.3 二类LDA算法原理？" class="md-nav__link">
    2.14.3 二类LDA算法原理？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2144-lda" title="2.14.4 LDA算法流程总结？" class="md-nav__link">
    2.14.4 LDA算法流程总结？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2145-ldapca" title="2.14.5 LDA和PCA区别？" class="md-nav__link">
    2.14.5 LDA和PCA区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2146-lda" title="2.14.6 LDA优缺点？" class="md-nav__link">
    2.14.6 LDA优缺点？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#215-pca" title="2.15  主成分分析（PCA）" class="md-nav__link">
    2.15  主成分分析（PCA）
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2151-pca" title="2.15.1 主成分分析（PCA）思想总结" class="md-nav__link">
    2.15.1 主成分分析（PCA）思想总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2152-pca" title="2.15.2 图解PCA核心思想" class="md-nav__link">
    2.15.2 图解PCA核心思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2153-pca" title="2.15.3 PCA算法推理" class="md-nav__link">
    2.15.3 PCA算法推理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2154-pca" title="2.15.4 PCA算法流程总结" class="md-nav__link">
    2.15.4 PCA算法流程总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2155-pca" title="2.15.5 PCA算法主要优缺点" class="md-nav__link">
    2.15.5 PCA算法主要优缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2156" title="2.15.6 降维的必要性及目的" class="md-nav__link">
    2.15.6 降维的必要性及目的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2157-kpcapca" title="2.15.7 KPCA与PCA的区别？" class="md-nav__link">
    2.15.7 KPCA与PCA的区别？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#216" title="2.16 模型评估" class="md-nav__link">
    2.16 模型评估
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2161" title="2.16.1 模型评估常用方法？" class="md-nav__link">
    2.16.1 模型评估常用方法？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2162" title="2.16.2 误差、偏差和方差有什么区别和联系？" class="md-nav__link">
    2.16.2 误差、偏差和方差有什么区别和联系？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2163" title="2.16.3 经验误差与泛化误差" class="md-nav__link">
    2.16.3 经验误差与泛化误差
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2164" title="2.16.4 图解欠拟合、过拟合" class="md-nav__link">
    2.16.4 图解欠拟合、过拟合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2165" title="2.16.5 如何解决过拟合与欠拟合？" class="md-nav__link">
    2.16.5 如何解决过拟合与欠拟合？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2166" title="2.16.6 交叉验证的主要作用" class="md-nav__link">
    2.16.6 交叉验证的主要作用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2167-k" title="2.16.7 理解k折交叉验证" class="md-nav__link">
    2.16.7 理解k折交叉验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2168" title="2.16.8 混淆矩阵" class="md-nav__link">
    2.16.8 混淆矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2169" title="2.16.9 错误率及精度" class="md-nav__link">
    2.16.9 错误率及精度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21610" title="2.16.10 查准率与查全率" class="md-nav__link">
    2.16.10 查准率与查全率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21611-rocauc" title="2.16.11 ROC与AUC" class="md-nav__link">
    2.16.11 ROC与AUC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21612-roc" title="2.16.12 如何画ROC曲线？" class="md-nav__link">
    2.16.12 如何画ROC曲线？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21613-tprfpr" title="2.16.13 如何计算TPR，FPR？" class="md-nav__link">
    2.16.13 如何计算TPR，FPR？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21614-auc" title="2.16.14 如何计算AUC？" class="md-nav__link">
    2.16.14 如何计算AUC？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21615-rocauc" title="2.16.15 为什么使用Roc和Auc评价分类器？" class="md-nav__link">
    2.16.15 为什么使用Roc和Auc评价分类器？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21616-auc" title="2.16.16 直观理解AUC" class="md-nav__link">
    2.16.16 直观理解AUC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21617" title="2.16.17 代价敏感错误率与代价曲线" class="md-nav__link">
    2.16.17 代价敏感错误率与代价曲线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21618" title="2.16.18 模型有哪些比较检验方法" class="md-nav__link">
    2.16.18 模型有哪些比较检验方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21619" title="2.16.19 为什么使用标准差？" class="md-nav__link">
    2.16.19 为什么使用标准差？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21620" title="2.16.20 类别不平衡产生原因？" class="md-nav__link">
    2.16.20 类别不平衡产生原因？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21621" title="2.16.21 常见的类别不平衡问题解决方法" class="md-nav__link">
    2.16.21 常见的类别不平衡问题解决方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#217" title="2.17 决策树" class="md-nav__link">
    2.17 决策树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2171" title="2.17.1 决策树的基本原理" class="md-nav__link">
    2.17.1 决策树的基本原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2172" title="2.17.2 决策树的三要素？" class="md-nav__link">
    2.17.2 决策树的三要素？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2173" title="2.17.3 决策树学习基本算法" class="md-nav__link">
    2.17.3 决策树学习基本算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2174" title="2.17.4 决策树算法优缺点" class="md-nav__link">
    2.17.4 决策树算法优缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2175" title="2.17.5 熵的概念以及理解" class="md-nav__link">
    2.17.5 熵的概念以及理解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2176" title="2.17.6 信息增益的理解" class="md-nav__link">
    2.17.6 信息增益的理解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2177" title="2.17.7 剪枝处理的作用及策略？" class="md-nav__link">
    2.17.7 剪枝处理的作用及策略？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#218" title="2.18 支持向量机" class="md-nav__link">
    2.18 支持向量机
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2181" title="2.18.1 什么是支持向量机" class="md-nav__link">
    2.18.1 什么是支持向量机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2182" title="2.18.2 支持向量机能解决哪些问题？" class="md-nav__link">
    2.18.2 支持向量机能解决哪些问题？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2183" title="2.18.3 核函数特点及其作用？" class="md-nav__link">
    2.18.3 核函数特点及其作用？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2184-svm" title="2.18.4 SVM为什么引入对偶问题？" class="md-nav__link">
    2.18.4 SVM为什么引入对偶问题？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2185-svm" title="2.18.5 如何理解SVM中的对偶问题" class="md-nav__link">
    2.18.5 如何理解SVM中的对偶问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2187" title="2.18.7 常见的核函数有哪些？" class="md-nav__link">
    2.18.7 常见的核函数有哪些？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2189-svm" title="2.18.9 SVM主要特点？" class="md-nav__link">
    2.18.9 SVM主要特点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21810-svm" title="2.18.10 SVM主要缺点？" class="md-nav__link">
    2.18.10 SVM主要缺点？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21811-svm" title="2.18.11 逻辑回归与SVM的异同" class="md-nav__link">
    2.18.11 逻辑回归与SVM的异同
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#219" title="2.19 贝叶斯分类器" class="md-nav__link">
    2.19 贝叶斯分类器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2191" title="2.19.1 图解极大似然估计" class="md-nav__link">
    2.19.1 图解极大似然估计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2192" title="2.19.2 极大似然估计原理" class="md-nav__link">
    2.19.2 极大似然估计原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2193" title="2.19.3 贝叶斯分类器基本原理" class="md-nav__link">
    2.19.3 贝叶斯分类器基本原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2194" title="2.19.4 朴素贝叶斯分类器" class="md-nav__link">
    2.19.4 朴素贝叶斯分类器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2195" title="2.19.5 举例理解朴素贝叶斯分类器" class="md-nav__link">
    2.19.5 举例理解朴素贝叶斯分类器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2196" title="2.19.6 半朴素贝叶斯分类器" class="md-nav__link">
    2.19.6 半朴素贝叶斯分类器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#220-em" title="2.20 EM算法" class="md-nav__link">
    2.20 EM算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2201-em" title="2.20.1 EM算法基本思想" class="md-nav__link">
    2.20.1 EM算法基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2202-em" title="2.20.2 EM算法推导" class="md-nav__link">
    2.20.2 EM算法推导
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2203-em" title="2.20.3 图解EM算法" class="md-nav__link">
    2.20.3 图解EM算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2204-em" title="2.20.4 EM算法流程" class="md-nav__link">
    2.20.4 EM算法流程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#221" title="2.21 降维和聚类" class="md-nav__link">
    2.21 降维和聚类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2211" title="2.21.1 图解为什么会产生“维数灾难”？" class="md-nav__link">
    2.21.1 图解为什么会产生“维数灾难”？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2212" title="2.21.2 怎样避免维数灾难" class="md-nav__link">
    2.21.2 怎样避免维数灾难
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2213" title="2.21.3 聚类和降维有什么区别与联系？" class="md-nav__link">
    2.21.3 聚类和降维有什么区别与联系？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2214" title="2.21.4 有哪些聚类算法优劣衡量标准" class="md-nav__link">
    2.21.4 有哪些聚类算法优劣衡量标准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2215" title="2.21.5 聚类和分类有什么区别？" class="md-nav__link">
    2.21.5 聚类和分类有什么区别？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2216" title="2.21.6 不同聚类算法特点性能比较" class="md-nav__link">
    2.21.6 不同聚类算法特点性能比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2217" title="2.21.7 四种常用聚类方法之比较" class="md-nav__link">
    2.21.7 四种常用聚类方法之比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2218-k-means" title="2.21.8 k-means聚类算法" class="md-nav__link">
    2.21.8 k-means聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2219" title="2.21.9 层次聚类算法" class="md-nav__link">
    2.21.9 层次聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22110-som" title="2.21.10 SOM聚类算法" class="md-nav__link">
    2.21.10 SOM聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22111-fcm" title="2.21.11 FCM聚类算法" class="md-nav__link">
    2.21.11 FCM聚类算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22112" title="2.21.12 四种聚类算法试验" class="md-nav__link">
    2.21.12 四种聚类算法试验
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#222-gbdt" title="2.22 GBDT和随机森林的区别" class="md-nav__link">
    2.22 GBDT和随机森林的区别
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#223-one-hot-encodeing" title="2.23 理解 One Hot Encodeing 原理及作用？" class="md-nav__link">
    2.23 理解 One Hot Encodeing 原理及作用？
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#224" title="2.24 大数据与深度学习之间的关系" class="md-nav__link">
    2.24 大数据与深度学习之间的关系
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="参考文献" class="md-nav__link">
    参考文献
  </a>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/myourdream/aiwiki/blob/master/docs/qa500/ch02_机器学习基础/第二章_机器学习基础.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <div class="toc">
<ul>
<li><a href="#_1">第二章 机器学习基础</a><ul>
<li><a href="#21">2.1 大话理解机器学习本质</a></li>
<li><a href="#22">2.2 各种常见算法图示</a></li>
<li><a href="#23">2.3 监督学习、非监督学习、半监督学习、弱监督学习？</a></li>
<li><a href="#24">2.4 监督学习有哪些步骤</a></li>
<li><a href="#25">2.5 多实例学习？</a></li>
<li><a href="#26">2.6 什么是神经网络？</a></li>
<li><a href="#27">2.7 理解局部最优与全局最优</a></li>
<li><a href="#28">2.8 分类算法</a><ul>
<li><a href="#281">2.8.1 常用分类算法的优缺点？</a></li>
<li><a href="#282">2.8.2 分类算法的评估方法？</a></li>
<li><a href="#283">2.8.3 正确率能很好的评估分类算法吗？</a></li>
<li><a href="#284">2.8.4 什么样的分类器是最好的？</a></li>
</ul>
</li>
<li><a href="#29">2.9 逻辑回归</a><ul>
<li><a href="#291">2.9.1 回归划分</a></li>
<li><a href="#292">2.9.2 逻辑回归适用性</a></li>
<li><a href="#293">2.9.3 逻辑回归与朴素贝叶斯有什么区别？</a></li>
<li><a href="#294">2.9.4 线性回归与逻辑回归的区别？</a></li>
</ul>
</li>
<li><a href="#210">2.10 代价函数</a><ul>
<li><a href="#2101">2.10.1 为什么需要代价函数？</a></li>
<li><a href="#2102">2.10.2 代价函数作用原理</a></li>
<li><a href="#2103">2.10.3 为什么代价函数要非负？</a></li>
<li><a href="#2104">2.10.4 常见代价函数？</a></li>
<li><a href="#2105">2.10.5 为什么用交叉熵代替二次代价函数</a></li>
</ul>
</li>
<li><a href="#211">2.11 损失函数</a><ul>
<li><a href="#2111">2.11.1 什么是损失函数？</a></li>
<li><a href="#2112">2.11.2 常见的损失函数</a></li>
<li><a href="#2113">2.11.3 逻辑回归为什么使用对数损失函数？</a></li>
<li><a href="#2114">2.11.4 对数损失函数是如何度量损失的？</a></li>
</ul>
</li>
<li><a href="#212">2.12 梯度下降</a><ul>
<li><a href="#2121">2.12.1 机器学习中为什么需要梯度下降？</a></li>
<li><a href="#2122">2.12.2 梯度下降法缺点？</a></li>
<li><a href="#2123">2.12.3 梯度下降法直观理解？</a></li>
<li><a href="#2124">2.12.4 梯度下降法算法描述</a></li>
<li><a href="#2125">2.12.5 如何对梯度下降法进行调优？</a></li>
<li><a href="#2126">2.12.6 随机梯度和批量梯度区别？</a></li>
<li><a href="#2127">2.12.7 各种梯度下降法性能比较</a></li>
</ul>
</li>
<li><a href="#213">2.13 计算图的导数计算？</a></li>
<li><a href="#214-lda">2.14 线性判别分析（LDA）</a><ul>
<li><a href="#2141-lda">2.14.1 LDA思想总结</a></li>
<li><a href="#2142-lda">2.14.2 图解LDA核心思想</a></li>
<li><a href="#2143-lda">2.14.3 二类LDA算法原理？</a></li>
<li><a href="#2144-lda">2.14.4 LDA算法流程总结？</a></li>
<li><a href="#2145-ldapca">2.14.5 LDA和PCA区别？</a></li>
<li><a href="#2146-lda">2.14.6 LDA优缺点？</a></li>
</ul>
</li>
<li><a href="#215-pca">2.15  主成分分析（PCA）</a><ul>
<li><a href="#2151-pca">2.15.1 主成分分析（PCA）思想总结</a></li>
<li><a href="#2152-pca">2.15.2 图解PCA核心思想</a></li>
<li><a href="#2153-pca">2.15.3 PCA算法推理</a></li>
<li><a href="#2154-pca">2.15.4 PCA算法流程总结</a></li>
<li><a href="#2155-pca">2.15.5 PCA算法主要优缺点</a></li>
<li><a href="#2156">2.15.6 降维的必要性及目的</a></li>
<li><a href="#2157-kpcapca">2.15.7 KPCA与PCA的区别？</a></li>
</ul>
</li>
<li><a href="#216">2.16 模型评估</a><ul>
<li><a href="#2161">2.16.1 模型评估常用方法？</a></li>
<li><a href="#2162">2.16.2 误差、偏差和方差有什么区别和联系？</a></li>
<li><a href="#2163">2.16.3 经验误差与泛化误差</a></li>
<li><a href="#2164">2.16.4 图解欠拟合、过拟合</a></li>
<li><a href="#2165">2.16.5 如何解决过拟合与欠拟合？</a></li>
<li><a href="#2166">2.16.6 交叉验证的主要作用</a></li>
<li><a href="#2167-k">2.16.7 理解k折交叉验证</a></li>
<li><a href="#2168">2.16.8 混淆矩阵</a></li>
<li><a href="#2169">2.16.9 错误率及精度</a></li>
<li><a href="#21610">2.16.10 查准率与查全率</a></li>
<li><a href="#21611-rocauc">2.16.11 ROC与AUC</a></li>
<li><a href="#21612-roc">2.16.12 如何画ROC曲线？</a></li>
<li><a href="#21613-tprfpr">2.16.13 如何计算TPR，FPR？</a></li>
<li><a href="#21614-auc">2.16.14 如何计算AUC？</a></li>
<li><a href="#21615-rocauc">2.16.15 为什么使用Roc和Auc评价分类器？</a></li>
<li><a href="#21616-auc">2.16.16 直观理解AUC</a></li>
<li><a href="#21617">2.16.17 代价敏感错误率与代价曲线</a></li>
<li><a href="#21618">2.16.18 模型有哪些比较检验方法</a></li>
<li><a href="#21619">2.16.19 为什么使用标准差？</a></li>
<li><a href="#21620">2.16.20 类别不平衡产生原因？</a></li>
<li><a href="#21621">2.16.21 常见的类别不平衡问题解决方法</a></li>
</ul>
</li>
<li><a href="#217">2.17 决策树</a><ul>
<li><a href="#2171">2.17.1 决策树的基本原理</a></li>
<li><a href="#2172">2.17.2 决策树的三要素？</a></li>
<li><a href="#2173">2.17.3 决策树学习基本算法</a></li>
<li><a href="#2174">2.17.4 决策树算法优缺点</a></li>
<li><a href="#2175">2.17.5 熵的概念以及理解</a></li>
<li><a href="#2176">2.17.6 信息增益的理解</a></li>
<li><a href="#2177">2.17.7 剪枝处理的作用及策略？</a></li>
</ul>
</li>
<li><a href="#218">2.18 支持向量机</a><ul>
<li><a href="#2181">2.18.1 什么是支持向量机</a></li>
<li><a href="#2182">2.18.2 支持向量机能解决哪些问题？</a></li>
<li><a href="#2183">2.18.3 核函数特点及其作用？</a></li>
<li><a href="#2184-svm">2.18.4 SVM为什么引入对偶问题？</a></li>
<li><a href="#2185-svm">2.18.5 如何理解SVM中的对偶问题</a></li>
<li><a href="#2187">2.18.7 常见的核函数有哪些？</a></li>
<li><a href="#2189-svm">2.18.9 SVM主要特点？</a></li>
<li><a href="#21810-svm">2.18.10 SVM主要缺点？</a></li>
<li><a href="#21811-svm">2.18.11 逻辑回归与SVM的异同</a></li>
</ul>
</li>
<li><a href="#219">2.19 贝叶斯分类器</a><ul>
<li><a href="#2191">2.19.1 图解极大似然估计</a></li>
<li><a href="#2192">2.19.2 极大似然估计原理</a></li>
<li><a href="#2193">2.19.3 贝叶斯分类器基本原理</a></li>
<li><a href="#2194">2.19.4 朴素贝叶斯分类器</a></li>
<li><a href="#2195">2.19.5 举例理解朴素贝叶斯分类器</a></li>
<li><a href="#2196">2.19.6 半朴素贝叶斯分类器</a></li>
</ul>
</li>
<li><a href="#220-em">2.20 EM算法</a><ul>
<li><a href="#2201-em">2.20.1 EM算法基本思想</a></li>
<li><a href="#2202-em">2.20.2 EM算法推导</a></li>
<li><a href="#2203-em">2.20.3 图解EM算法</a></li>
<li><a href="#2204-em">2.20.4 EM算法流程</a></li>
</ul>
</li>
<li><a href="#221">2.21 降维和聚类</a><ul>
<li><a href="#2211">2.21.1 图解为什么会产生“维数灾难”？</a></li>
<li><a href="#2212">2.21.2 怎样避免维数灾难</a></li>
<li><a href="#2213">2.21.3 聚类和降维有什么区别与联系？</a></li>
<li><a href="#2214">2.21.4 有哪些聚类算法优劣衡量标准</a></li>
<li><a href="#2215">2.21.5 聚类和分类有什么区别？</a></li>
<li><a href="#2216">2.21.6 不同聚类算法特点性能比较</a></li>
<li><a href="#2217">2.21.7 四种常用聚类方法之比较</a></li>
<li><a href="#2218-k-means">2.21.8 k-means聚类算法</a></li>
<li><a href="#2219">2.21.9 层次聚类算法</a></li>
<li><a href="#22110-som">2.21.10 SOM聚类算法</a></li>
<li><a href="#22111-fcm">2.21.11 FCM聚类算法</a></li>
<li><a href="#22112">2.21.12 四种聚类算法试验</a></li>
</ul>
</li>
<li><a href="#222-gbdt">2.22 GBDT和随机森林的区别</a></li>
<li><a href="#223-one-hot-encodeing">2.23 理解 One Hot Encodeing 原理及作用？</a></li>
<li><a href="#224">2.24 大数据与深度学习之间的关系</a></li>
<li><a href="#_2">参考文献</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1">第二章 机器学习基础<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="21">2.1 大话理解机器学习本质<a class="headerlink" href="#21" title="Permanent link">&para;</a></h2>
<p>​   机器学习(Machine Learning, ML)，顾名思义，让机器去学习。这里，机器指的是计算机，是算法运行的物理载体，你也可以把各种算法本身当做一个有输入和输出的机器。那么到底让计算机去学习什么呢？对于一个任务及其表现的度量方法，设计一种算法，让算法能够提取中数据所蕴含的规律，这就叫机器学习。如果输入机器的数据是带有标签的，就称作有监督学习。如果数据是无标签的，就是无监督学习。</p>
<h2 id="22">2.2 各种常见算法图示<a class="headerlink" href="#22" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th align="center">回归算法</th>
<th align="center">聚类算法</th>
<th align="center">正则化方法</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="../img/ch2/2.1/1.jpg" /></td>
<td align="center"><img alt="" src="../img/ch2/2.1/2.jpg" /></td>
<td align="center"><img alt="" src="../img/ch2/2.1/3.jpg" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">决策树学习</th>
<th align="center">贝叶斯方法</th>
<th align="center">基于核的算法</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="../img/ch2/2.2.4.png" /></td>
<td align="center"><img alt="" src="../img/ch2/2.1/5.jpg" /></td>
<td align="center"><img alt="" src="../img/ch2/2.1/6.jpg" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">聚类算法</th>
<th align="center">关联规则学习</th>
<th align="center">人工神经网络</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="../img/ch2/2.1/7.jpg" /></td>
<td align="center"><img alt="" src="../img/ch2/2.2.8.png" /></td>
<td align="center"><img alt="" src="../img/ch2/2.2.09.png" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">深度学习</th>
<th align="center">降低维度算法</th>
<th align="center">集成算法</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="../img/ch2/2.2.10.png" /></td>
<td align="center"><img alt="" src="../img/ch2/2.2.11.png" /></td>
<td align="center"><img alt="" src="../img/ch2/2.2.12.png" /></td>
</tr>
</tbody>
</table>
<h2 id="23">2.3 监督学习、非监督学习、半监督学习、弱监督学习？<a class="headerlink" href="#23" title="Permanent link">&para;</a></h2>
<p>​   根据数据类型的不同，对一个问题的建模有不同的方式。依据不同的学习方式和输入数据，机器学习主要分为以下四种学习方式。</p>
<p><strong>监督学习</strong>：
1. 监督学习是使用已知正确答案的示例来训练网络。已知数据和其一一对应的标签，训练一个预测模型，将输入数据映射到标签的过程。
2. 监督式学习的常见应用场景如分类问题和回归问题。
3. 常见的有监督机器学习算法包括支持向量机(Support Vector Machine, SVM)，朴素贝叶斯(Naive Bayes)，逻辑回归(Logistic Regression)，K近邻(K-Nearest Neighborhood, KNN)，决策树(Decision Tree)，随机森林(Random Forest)，AdaBoost以及线性判别分析(Linear Discriminant Analysis, LDA)等。深度学习(Deep Learning)也是大多数以监督学习的方式呈现。</p>
<p><strong>非监督式学习</strong>：
1. 在非监督式学习中，数据并不被特别标识，适用于你具有数据集但无标签的情况。学习模型是为了推断出数据的一些内在结构。
2. 常见的应用场景包括关联规则的学习以及聚类等。
3. 常见算法包括Apriori算法以及k-Means算法。</p>
<p><strong>半监督式学习</strong>：
1. 在此学习方式下，输入数据部分被标记，部分没有被标记，这种学习模型可以用来进行预测。
2. 应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，通过对已标记数据建模，在此基础上，对未标记数据进行预测。
3. 常见算法如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM）等。</p>
<p><strong>弱监督学习</strong>：
1. 弱监督学习可以看做是有多个标记的数据集合，次集合可以是空集，单个元素，或包含多种情况（没有标记，有一个标记，和有多个标记）的多个元素。 
2. 数据集的标签是不可靠的，这里的不可靠可以是标记不正确，多种标记，标记不充分，局部标记等。
3. 已知数据和其一一对应的弱标签，训练一个智能算法，将输入数据映射到一组更强的标签的过程。标签的强弱指的是标签蕴含的信息量的多少，比如相对于分割的标签来说，分类的标签就是弱标签。
4. 举例，给出一张包含气球的图片，需要得出气球在图片中的位置及气球和背景的分割线，这就是已知弱标签学习强标签的问题。</p>
<p>​   在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。</p>
<h2 id="24">2.4 监督学习有哪些步骤<a class="headerlink" href="#24" title="Permanent link">&para;</a></h2>
<p>​   监督学习是使用已知正确答案的示例来训练网络，每组训练数据有一个明确的标识或结果。想象一下，我们可以训练一个网络，让其从照片库中（其中包含气球的照片）识别出气球的照片。以下就是我们在这个假设场景中所要采取的步骤。</p>
<p><strong>步骤1：数据集的创建和分类</strong>
​   首先，浏览你的照片（数据集），确定所有包含气球的照片，并对其进行标注。然后，将所有照片分为训练集和验证集。目标就是在深度网络中找一函数，这个函数输入是任意一张照片，当照片中包含气球时，输出1，否则输出0。</p>
<p><strong>步骤2：数据增强（Data Augmentation）</strong>
​   当原始数据搜集和标注完毕，一般搜集的数据并不一定包含目标在各种扰动下的信息。数据的好坏对于机器学习模型的预测能力至关重要，因此一般会进行数据增强。对于图像数据来说，数据增强一般包括，图像旋转，平移，颜色变换，裁剪，仿射变换等。</p>
<p><strong>步骤3：特征工程（Feature Engineering）</strong>
​   一般来讲，特征工程包含特征提取和特征选择。常见的手工特征(Hand-Crafted Feature)有尺度不变特征变换(Scale-Invariant Feature Transform, SIFT)，方向梯度直方图(Histogram of Oriented Gradient, HOG)等。由于手工特征是启发式的，其算法设计背后的出发点不同，将这些特征组合在一起的时候有可能会产生冲突，如何将组合特征的效能发挥出来，使原始数据在特征空间中的判别性最大化，就需要用到特征选择的方法。在深度学习方法大获成功之后，人们很大一部分不再关注特征工程本身。因为，最常用到的卷积神经网络(Convolutional Neural Networks, CNNs)本身就是一种特征提取和选择的引擎。研究者提出的不同的网络结构、正则化、归一化方法实际上就是深度学习背景下的特征工程。</p>
<p><strong>步骤4：构建预测模型和损失</strong>
​   将原始数据映射到特征空间之后，也就意味着我们得到了比较合理的输入。下一步就是构建合适的预测模型得到对应输入的输出。而如何保证模型的输出和输入标签的一致性，就需要构建模型预测和标签之间的损失函数，常见的损失函数(Loss Function)有交叉熵、均方差等。通过优化方法不断迭代，使模型从最初的初始化状态一步步变化为有预测能力的模型的过程，实际上就是学习的过程。</p>
<p><strong>步骤5：训练</strong>
​   选择合适的模型和超参数进行初始化，其中超参数比如支持向量机中核函数、误差项惩罚权重等。当模型初始化参数设定好后，将制作好的特征数据输入到模型，通过合适的优化方法不断缩小输出与标签之间的差距，当迭代过程到了截止条件，就可以得到训练好的模型。优化方法最常见的就是梯度下降法及其变种，使用梯度下降法的前提是优化目标函数对于模型是可导的。</p>
<p><strong>步骤6：验证和模型选择</strong>
​   训练完训练集图片后，需要进行模型测试。利用验证集来验证模型是否可以准确地挑选出含有气球在内的照片。
​   在此过程中，通常会通过调整和模型相关的各种事物（超参数）来重复步骤2和3，诸如里面有多少个节点，有多少层，使用怎样的激活函数和损失函数，如何在反向传播阶段积极有效地训练权值等等。</p>
<p><strong>步骤7：测试及应用</strong>
​   当有了一个准确的模型，就可以将该模型部署到你的应用程序中。你可以将预测功能发布为API（Application Programming Interface, 应用程序编程接口）调用，并且你可以从软件中调用该API，从而进行推理并给出相应的结果。</p>
<h2 id="25">2.5 多实例学习？<a class="headerlink" href="#25" title="Permanent link">&para;</a></h2>
<p>​   多实例学习(Multiple Instance Learning, MIL) ：已知包含多个数据的数据包和数据包的标签，训练智能算法，将数据包映射到标签的过程，在有的问题中也同时给出包内每个数据的标签。
​   比如说一段视频由很多张图组成，假如10000张，那么我们要判断视频里是否包含某一物体，比如气球。单张标注每一帧是否有气球太耗时，通常人们看一遍说这个视频里是否有气球，就得到了多示例学习的数据。10000帧的数据不是每一个都有气球出现，只要有一帧有气球，那么我们就认为这个数据包是有气球的。只有当所有的视频帧都没有气球，才是没有气球的。从这里面学习哪一段视频（10000张）是否有气球出现就是多实例学习的问题。</p>
<h2 id="26">2.6 什么是神经网络？<a class="headerlink" href="#26" title="Permanent link">&para;</a></h2>
<p>​   神经网络就是按照一定规则将多个神经元连接起来的网络。不同的神经网络，具有不同的连接规则。
例如全连接(Full Connected, FC)神经网络，它的规则包括：</p>
<ol>
<li>有三种层：输入层，输出层，隐藏层。</li>
<li>同一层的神经元之间没有连接。</li>
<li>fully connected的含义：第 N 层的每个神经元和第 N-1 层的所有神经元相连，第 N-1 层神经元的输出就是第 N 层神经元的输入。</li>
<li>
<p>每个连接都有一个权值。</p>
<p><strong>神经网络架构</strong>
​   下面这张图就是一个神经网络系统，它由很多层组成。输入层负责接收信息，比如一只猫的图片。输出层是计算机对这个输入信息的判断结果，它是不是猫。隐藏层就是对输入信息的传递和加工处理。
<img alt="" src="../img/ch2/2.5.1.png" /></p>
</li>
</ol>
<h2 id="27">2.7 理解局部最优与全局最优<a class="headerlink" href="#27" title="Permanent link">&para;</a></h2>
<p>​   笑谈局部最优和全局最优</p>
<blockquote>
<p>​ 柏拉图有一天问老师苏格拉底什么是爱情？苏格拉底叫他到麦田走一次，摘一颗最大的麦穗回来，不许回头，只可摘一次。柏拉图空着手出来了，他的理由是，看见不错的，却不知道是不是最好的，一次次侥幸，走到尽头时，才发现还不如前面的，于是放弃。苏格拉底告诉他：“这就是爱情。”这故事让我们明白了一个道理，因为生命的一些不确定性，所以全局最优解是很难寻找到的，或者说根本就不存在，我们应该设置一些限定条件，然后在这个范围内寻找最优解，也就是局部最优解——有所斩获总比空手而归强，哪怕这种斩获只是一次有趣的经历。
​ 柏拉图有一天又问什么是婚姻？苏格拉底叫他到树林走一次,选一棵最好的树做圣诞树，也是不许回头，只许选一次。这次他一身疲惫地拖了一棵看起来直挺、翠绿，却有点稀疏的杉树回来，他的理由是，有了上回的教训，好不容易看见一棵看似不错的，又发现时间、体力已经快不够用了，也不管是不是最好的，就拿回来了。苏格拉底告诉他：“这就是婚姻。”</p>
</blockquote>
<p>​   优化问题一般分为局部最优和全局最优。</p>
<ol>
<li>局部最优，就是在函数值空间的一个有限区域内寻找最小值；而全局最优，是在函数值空间整个区域寻找最小值问题。</li>
<li>函数局部最小点是它的函数值小于或等于附近点的点。但是有可能大于较远距离的点。</li>
<li>全局最小点是那种它的函数值小于或等于所有的可行点。</li>
</ol>
<h2 id="28">2.8 分类算法<a class="headerlink" href="#28" title="Permanent link">&para;</a></h2>
<p>​   分类算法和回归算法是对真实世界不同建模的方法。分类模型是认为模型的输出是离散的，例如大自然的生物被划分为不同的种类，是离散的。回归模型的输出是连续的，例如人的身高变化过程是一个连续过程，而不是离散的。</p>
<p>​   因此，在实际建模过程时，采用分类模型还是回归模型，取决于你对任务（真实世界）的分析和理解。</p>
<h3 id="281">2.8.1 常用分类算法的优缺点？<a class="headerlink" href="#281" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Bayes 贝叶斯分类法</td>
<td align="left">1）所需估计的参数少，对于缺失数据不敏感。<br />2）有着坚实的数学基础，以及稳定的分类效率。</td>
<td align="left">1）需要假设属性之间相互独立，这往往并不成立。（喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋）。<br />2）需要知道先验概率。<br />3）分类决策存在错误率。</td>
</tr>
<tr>
<td align="left">Decision Tree决策树</td>
<td align="left">1）不需要任何领域知识或参数假设。<br />2）适合高维数据。<br />3）简单易于理解。<br />4）短时间内处理大量数据，得到可行且效果较好的结果。<br />5）能够同时处理数据型和常规性属性。</td>
<td align="left">1）对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。<br />2）易于过拟合。<br />3）忽略属性之间的相关性。<br />4）不支持在线学习。</td>
</tr>
<tr>
<td align="left">SVM支持向量机</td>
<td align="left">1）可以解决小样本下机器学习的问题。<br />2）提高泛化性能。<br />3）可以解决高维、非线性问题。超高维文本分类仍受欢迎。<br />4）避免神经网络结构选择和局部极小的问题。</td>
<td align="left">1）对缺失数据敏感。<br />2）内存消耗大，难以解释。<br />3）运行和调参略烦人。</td>
</tr>
<tr>
<td align="left">KNN K近邻</td>
<td align="left">1）思想简单，理论成熟，既可以用来做分类也可以用来做回归； <br />2）可用于非线性分类；<br /> 3）训练时间复杂度为O(n)； <br />4）准确度高，对数据没有假设，对outlier不敏感；</td>
<td align="left">1）计算量太大。<br />2）对于样本分类不均衡的问题，会产生误判。<br />3）需要大量的内存。<br />4）输出的可解释性不强。</td>
</tr>
<tr>
<td align="left">Logistic Regression逻辑回归</td>
<td align="left">1）速度快。<br />2）简单易于理解，直接看到各个特征的权重。<br />3）能容易地更新模型吸收新的数据。<br />4）如果想要一个概率框架，动态调整分类阀值。</td>
<td align="left">特征处理复杂。需要归一化和较多的特征工程。</td>
</tr>
<tr>
<td align="left">Neural Network 神经网络</td>
<td align="left">1）分类准确率高。<br />2）并行处理能力强。<br />3）分布式存储和学习能力强。<br />4）鲁棒性较强，不易受噪声影响。</td>
<td align="left">1）需要大量参数（网络拓扑、阀值、阈值）。<br />2）结果难以解释。<br />3）训练时间过长。</td>
</tr>
<tr>
<td align="left">Adaboosting</td>
<td align="left">1）adaboost是一种有很高精度的分类器。<br />2）可以使用各种方法构建子分类器，Adaboost算法提供的是框架。<br />3）当使用简单分类器时，计算出的结果是可以理解的。而且弱分类器构造极其简单。<br />4）简单，不用做特征筛选。<br />5）不用担心overfitting。</td>
<td align="left">对outlier比较敏感</td>
</tr>
</tbody>
</table>
<h3 id="282">2.8.2 分类算法的评估方法？<a class="headerlink" href="#282" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>几个常用术语</strong>
    ​   这里首先介绍几个常见的模型评价术语，现在假设我们的分类目标只有两类，计为正例（positive）和负例（negative）分别是：
   1) True positives(TP):  被正确地划分为正例的个数，即实际为正例且被分类器划分为正例的实例数；
   2) False positives(FP): 被错误地划分为正例的个数，即实际为负例但被分类器划分为正例的实例数；
   3) False negatives(FN):被错误地划分为负例的个数，即实际为正例但被分类器划分为负例的实例数；
   4) True negatives(TN): 被正确地划分为负例的个数，即实际为负例且被分类器划分为负例的实例数。　</li>
</ul>
<p><img alt="" src="../img/ch2/2.9/1.png" /></p>
<p>上图是这四个术语的混淆矩阵，做以下说明：
    1）P=TP+FN表示实际为正例的样本个数。
    2）True、False描述的是分类器是否判断正确。
    3）Positive、Negative是分类器的分类结果，如果正例计为1、负例计为-1，即positive=1、negative=-1。用1表示True，-1表示False，那么实际的类标=TF*PN，TF为true或false，PN为positive或negative。
    4）例如True positives(TP)的实际类标=1*1=1为正例，False positives(FP)的实际类标=(-1)*1=-1为负例，False negatives(FN)的实际类标=(-1)*(-1)=1为正例，True negatives(TN)的实际类标=1*(-1)=-1为负例。</p>
<ul>
<li><strong>评价指标</strong>
  1) 正确率（accuracy）
    正确率是我们最常见的评价指标，accuracy = (TP+TN)/(P+N)，正确率是被分对的样本数在所有样本数中的占比，通常来说，正确率越高，分类器越好。
  2) 错误率（error rate)
    错误率则与正确率相反，描述被分类器错分的比例，error rate = (FP+FN)/(P+N)，对某一个实例来说，分对与分错是互斥事件，所以accuracy =1 -  error rate。
  3) 灵敏度（sensitivity）
    sensitivity = TP/P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力。
  4) 特异性（specificity)
    specificity = TN/N，表示的是所有负例中被分对的比例，衡量了分类器对负例的识别能力。
  5) 精度（precision）
    precision=TP/(TP+FP)，精度是精确性的度量，表示被分为正例的示例中实际为正例的比例。
  6) 召回率（recall）
    召回率是覆盖面的度量，度量有多个正例被分为正例，recall=TP/(TP+FN)=TP/P=sensitivity，可以看到召回率与灵敏度是一样的。
  7) 其他评价指标
    计算速度：分类器训练和预测需要的时间；
    鲁棒性：处理缺失值和异常值的能力；
    可扩展性：处理大数据集的能力；
    可解释性：分类器的预测标准的可理解性，像决策树产生的规则就是很容易理解的，而神经网络的一堆参数就不好理解，我们只好把它看成一个黑盒子。
  8) 精度和召回率反映了分类器分类性能的两个方面。如果综合考虑查准率与查全率，可以得到新的评价指标F1-score，也称为综合分类率：<span><span class="MathJax_Preview">F1=\frac{2 \times precision \times recall}{precision + recall}​</span><script type="math/tex">F1=\frac{2 \times precision \times recall}{precision + recall}​</script></span>。</li>
</ul>
<p>​   为了综合多个类别的分类情况，评测系统整体性能，经常采用的还有微平均F1（micro-averaging）和宏平均F1（macro-averaging ）两种指标。</p>
<p>​   （1）宏平均F1与微平均F1是以两种不同的平均方式求的全局F1指标。</p>
<p>​   （2）宏平均F1的计算方法先对每个类别单独计算F1值，再取这些F1值的算术平均值作为全局指标。</p>
<p>​   （3）微平均F1的计算方法是先累加计算各个类别的a、b、c、d的值，再由这些值求出F1值。</p>
<p>​   （4）由两种平均F1的计算方式不难看出，宏平均F1平等对待每一个类别，所以它的值主要受到稀有类别的影响，而微平均F1平等考虑文档集中的每一个文档，所以它的值受到常见类别的影响比较大。</p>
<ul>
<li><strong>ROC曲线和PR曲线</strong></li>
</ul>
<p>​   ROC曲线是（Receiver Operating Characteristic Curve，受试者工作特征曲线）的简称，是以灵敏度（真阳性率）为纵坐标，以1减去特异性（假阳性率）为横坐标绘制的性能评价曲线。可以将不同模型对同一数据集的ROC曲线绘制在同一笛卡尔坐标系中，ROC曲线越靠近左上角，说明其对应模型越可靠。也可以通过ROC曲线下面的面积（Area Under Curve, AUC）来评价模型，AUC越大，模型越可靠。</p>
<p><img alt="" src="../img/ch2/2.7.3.png" /></p>
<p>​                                                                            图2.8.2.1 ROC曲线</p>
<p>​   PR曲线是Precision Recall Curve的简称，描述的是precision和recall之间的关系，以recall为横坐标，precision为纵坐标绘制的曲线。该曲线的所对应的面积AUC实际上是目标检测中常用的评价指标平均精度（Average Precision, AP）。AP越高，说明模型性能越好。</p>
<h3 id="283">2.8.3 正确率能很好的评估分类算法吗？<a class="headerlink" href="#283" title="Permanent link">&para;</a></h3>
<p>​   不同算法有不同特点，在不同数据集上有不同的表现效果，根据特定的任务选择不同的算法。如何评价分类算法的好坏，要做具体任务具体分析。对于决策树，主要用正确率去评估，但是其他算法，只用正确率能很好的评估吗？
​   答案是否定的。
​   正确率确实是一个很直观很好的评价指标，但是有时候正确率高并不能完全代表一个算法就好。比如对某个地区进行地震预测，地震分类属性分为0：不发生地震、1发生地震。我们都知道，不发生的概率是极大的，对于分类器而言，如果分类器不加思考，对每一个测试样例的类别都划分为0，达到99%的正确率，但是，问题来了，如果真的发生地震时，这个分类器毫无察觉，那带来的后果将是巨大的。很显然，99%正确率的分类器并不是我们想要的。出现这种现象的原因主要是数据分布不均衡，类别为1的数据太少，错分了类别1但达到了很高的正确率缺忽视了研究者本身最为关注的情况。</p>
<h3 id="284">2.8.4 什么样的分类器是最好的？<a class="headerlink" href="#284" title="Permanent link">&para;</a></h3>
<p>​   对某一个任务，某个具体的分类器不可能同时满足或提高所有上面介绍的指标。
​   如果一个分类器能正确分对所有的实例，那么各项指标都已经达到最优，但这样的分类器往往不存在。比如之前说的地震预测，既然不能百分百预测地震的发生，但实际情况中能容忍一定程度的误报。假设在1000次预测中，共有5次预测发生了地震，真实情况中有一次发生了地震，其他4次则为误报。正确率由原来的999/1000=99.9下降为996/1000=99.6。召回率由0/1=0%上升为1/1=100%。对此解释为，虽然预测失误了4次，但真的地震发生前，分类器能预测对，没有错过，这样的分类器实际意义更为重大，正是我们想要的。在这种情况下，在一定正确率前提下，要求分类器的召回率尽量高。</p>
<h2 id="29">2.9 逻辑回归<a class="headerlink" href="#29" title="Permanent link">&para;</a></h2>
<h3 id="291">2.9.1 回归划分<a class="headerlink" href="#291" title="Permanent link">&para;</a></h3>
<p>广义线性模型家族里，依据因变量不同，可以有如下划分：</p>
<ol>
<li>如果是连续的，就是多重线性回归。</li>
<li>如果是二项分布，就是逻辑回归。</li>
<li>如果是泊松（Poisson）分布，就是泊松回归。</li>
<li>如果是负二项分布，就是负二项回归。</li>
<li>逻辑回归的因变量可以是二分类的，也可以是多分类的，但是二分类的更为常用，也更加容易解释。所以实际中最常用的就是二分类的逻辑回归。</li>
</ol>
<h3 id="292">2.9.2 逻辑回归适用性<a class="headerlink" href="#292" title="Permanent link">&para;</a></h3>
<ol>
<li>用于概率预测。用于可能性预测时，得到的结果有可比性。比如根据模型进而预测在不同的自变量情况下，发生某病或某种情况的概率有多大。</li>
<li>用于分类。实际上跟预测有些类似，也是根据模型，判断某人属于某病或属于某种情况的概率有多大，也就是看一下这个人有多大的可能性是属于某病。进行分类时，仅需要设定一个阈值即可，可能性高于阈值是一类，低于阈值是另一类。</li>
<li>寻找危险因素。寻找某一疾病的危险因素等。</li>
<li>仅能用于线性问题。只有当目标和特征是线性关系时，才能用逻辑回归。在应用逻辑回归时注意两点：一是当知道模型是非线性时，不适用逻辑回归；二是当使用逻辑回归时，应注意选择和目标为线性关系的特征。</li>
<li>各特征之间不需要满足条件独立假设，但各个特征的贡献独立计算。</li>
</ol>
<h3 id="293">2.9.3 逻辑回归与朴素贝叶斯有什么区别？<a class="headerlink" href="#293" title="Permanent link">&para;</a></h3>
<ol>
<li>逻辑回归是判别模型， 朴素贝叶斯是生成模型，所以生成和判别的所有区别它们都有。</li>
<li>朴素贝叶斯属于贝叶斯，逻辑回归是最大似然，两种概率哲学间的区别。</li>
<li>朴素贝叶斯需要条件独立假设。</li>
<li>逻辑回归需要求特征参数间是线性的。</li>
</ol>
<h3 id="294">2.9.4 线性回归与逻辑回归的区别？<a class="headerlink" href="#294" title="Permanent link">&para;</a></h3>
<p>（贡献者：黄钦建－华南理工大学）</p>
<p>​   线性回归的样本的输出，都是连续值，$ y\in (-\infty ,+\infty )<span><span class="MathJax_Preview">，而逻辑回归中</span><script type="math/tex">，而逻辑回归中</script></span>y\in (0,1)$，只能取0和1。</p>
<p>​   对于拟合函数也有本质上的差别： </p>
<p>​   线性回归：<span><span class="MathJax_Preview">f(x)=\theta ^{T}x=\theta _{1}x _{1}+\theta _{2}x _{2}+...+\theta _{n}x _{n}</span><script type="math/tex">f(x)=\theta ^{T}x=\theta _{1}x _{1}+\theta _{2}x _{2}+...+\theta _{n}x _{n}</script></span></p>
<p>​   逻辑回归：<span><span class="MathJax_Preview">f(x)=P(y=1|x;\theta )=g(\theta ^{T}x)</span><script type="math/tex">f(x)=P(y=1|x;\theta )=g(\theta ^{T}x)</script></span>，其中，<span><span class="MathJax_Preview">g(z)=\frac{1}{1+e^{-z}}</span><script type="math/tex">g(z)=\frac{1}{1+e^{-z}}</script></span></p>
<p>​   可以看出，线性回归的拟合函数，是对f(x)的输出变量y的拟合，而逻辑回归的拟合函数是对为1类样本的概率的拟合。</p>
<p>​   那么，为什么要以1类样本的概率进行拟合呢，为什么可以这样拟合呢？ </p>
<p>​   <span><span class="MathJax_Preview">\theta ^{T}x=0</span><script type="math/tex">\theta ^{T}x=0</script></span>就相当于是1类和0类的决策边界： </p>
<p>​   当<span><span class="MathJax_Preview">\theta ^{T}x&gt;0</span><script type="math/tex">\theta ^{T}x>0</script></span>，则y&gt;0.5；若$\theta ^{T}x\rightarrow +\infty <span><span class="MathJax_Preview">，则</span><script type="math/tex">，则</script></span>y \rightarrow  1 $，即y为1类; </p>
<p>​   当<span><span class="MathJax_Preview">\theta ^{T}x&lt;0</span><script type="math/tex">\theta ^{T}x<0</script></span>，则y&lt;0.5；若$\theta ^{T}x\rightarrow -\infty <span><span class="MathJax_Preview">，则</span><script type="math/tex">，则</script></span>y \rightarrow  0 $，即y为0类; </p>
<p>这个时候就能看出区别，在线性回归中<span><span class="MathJax_Preview">\theta ^{T}x</span><script type="math/tex">\theta ^{T}x</script></span>为预测值的拟合函数；而在逻辑回归中<span><span class="MathJax_Preview">\theta ^{T}x​</span><script type="math/tex">\theta ^{T}x​</script></span>为决策边界。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">线性回归</th>
<th align="center">逻辑回归</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">目的</td>
<td align="center">预测</td>
<td align="center">分类</td>
</tr>
<tr>
<td align="center"><span><span class="MathJax_Preview">y^{(i)}</span><script type="math/tex">y^{(i)}</script></span></td>
<td align="center">未知</td>
<td align="center">（0,1）</td>
</tr>
<tr>
<td align="center">函数</td>
<td align="center">拟合函数</td>
<td align="center">预测函数</td>
</tr>
<tr>
<td align="center">参数计算方式</td>
<td align="center">最小二乘法</td>
<td align="center">极大似然估计</td>
</tr>
</tbody>
</table>
<p>下面具体解释一下： </p>
<ol>
<li>拟合函数和预测函数什么关系呢？简单来说就是将拟合函数做了一个逻辑函数的转换，转换后使得<span><span class="MathJax_Preview">y^{(i)} \in (0,1)</span><script type="math/tex">y^{(i)} \in (0,1)</script></span>;</li>
<li>最小二乘和最大似然估计可以相互替代吗？回答当然是不行了。我们来看看两者依仗的原理：最大似然估计是计算使得数据出现的可能性最大的参数，依仗的自然是Probability。而最小二乘是计算误差损失。</li>
</ol>
<h2 id="210">2.10 代价函数<a class="headerlink" href="#210" title="Permanent link">&para;</a></h2>
<h3 id="2101">2.10.1 为什么需要代价函数？<a class="headerlink" href="#2101" title="Permanent link">&para;</a></h3>
<ol>
<li>为了得到训练逻辑回归模型的参数，需要一个代价函数，通过训练代价函数来得到参数。</li>
<li>用于找到最优解的目的函数。</li>
</ol>
<h3 id="2102">2.10.2 代价函数作用原理<a class="headerlink" href="#2102" title="Permanent link">&para;</a></h3>
<p>​   在回归问题中，通过代价函数来求解最优解，常用的是平方误差代价函数。有如下假设函数：</p>
<div>
<div class="MathJax_Preview">
h(x) = A + Bx
</div>
<script type="math/tex; mode=display">
h(x) = A + Bx
</script>
</div>
<p>​   假设函数中有<span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>和<span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>两个参数，当参数发生变化时，假设函数状态也会随着变化。
如下图所示：</p>
<p><img alt="" src="../img/ch2/2.16/1.jpg" /></p>
<p>​   想要拟合图中的离散点，我们需要尽可能找到最优的<span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>和<span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>来使这条直线更能代表所有数据。如何找到最优解呢，这就需要使用代价函数来求解，以平方误差代价函数为例，假设函数为<span><span class="MathJax_Preview">h(x)=\theta_0x</span><script type="math/tex">h(x)=\theta_0x</script></span>。
​   <strong>平方误差代价函数的主要思想</strong>就是将实际数据给出的值与拟合出的线的对应值做差，求出拟合出的直线与实际的差距。在实际应用中，为了避免因个别极端数据产生的影响，采用类似方差再取二分之一的方式来减小个别数据的影响。因此，引出代价函数：</p>
<div>
<div class="MathJax_Preview">
J(\theta_0, \theta_1) = \frac{1}{m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2
</div>
<script type="math/tex; mode=display">
J(\theta_0, \theta_1) = \frac{1}{m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2
</script>
</div>
<p>​   <strong>最优解即为代价函数的最小值</strong><span><span class="MathJax_Preview">\min J(\theta_0, \theta_1)​</span><script type="math/tex">\min J(\theta_0, \theta_1)​</script></span>。如果是1个参数，代价函数一般通过二维曲线便可直观看出。如果是2个参数，代价函数通过三维图像可看出效果，参数越多，越复杂。
当参数为2个时，代价函数是三维图像。</p>
<p><img alt="" src="../img/ch2/2.16/2.jpg" /></p>
<h3 id="2103">2.10.3 为什么代价函数要非负？<a class="headerlink" href="#2103" title="Permanent link">&para;</a></h3>
<p>​   目标函数存在一个下界，在优化过程当中，如果优化算法能够使目标函数不断减小，根据单调有界准则，这个优化算法就能证明是收敛有效的。
​   只要设计的目标函数有下界，基本上都可以，代价函数非负更为方便。</p>
<h3 id="2104">2.10.4 常见代价函数？<a class="headerlink" href="#2104" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>二次代价函数（quadratic cost）</strong>：</li>
</ol>
<div>
<div class="MathJax_Preview">
J = \frac{1}{2n}\sum_x\Vert y(x)-a^L(x)\Vert^2
</div>
<script type="math/tex; mode=display">
J = \frac{1}{2n}\sum_x\Vert y(x)-a^L(x)\Vert^2
</script>
</div>
<p>​   其中，<span><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>表示代价函数，<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>表示样本，<span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>示实际值，<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>表示输出值，<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>表示样本的总数。使用一个样本为例简单说明，此时二次代价函数为：
$$
J = \frac{(y-a)^2}{2}
$$
​   假如使用梯度下降法（Gradient descent）来调整权值参数的大小，权值<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>和偏置<span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>的梯度推导如下：
$$
\frac{\partial J}{\partial b}=(a-y)\sigma'(z)
$$
其中，<span><span class="MathJax_Preview">z​</span><script type="math/tex">z​</script></span>表示神经元的输入，<span><span class="MathJax_Preview">\sigma​</span><script type="math/tex">\sigma​</script></span>表示激活函数。权值<span><span class="MathJax_Preview">w​</span><script type="math/tex">w​</script></span>和偏置<span><span class="MathJax_Preview">b​</span><script type="math/tex">b​</script></span>的梯度跟激活函数的梯度成正比，激活函数的梯度越大，权值<span><span class="MathJax_Preview">w​</span><script type="math/tex">w​</script></span>和偏置<span><span class="MathJax_Preview">b​</span><script type="math/tex">b​</script></span>的大小调整得越快，训练收敛得就越快。</p>
<p><em>注</em>：神经网络常用的激活函数为sigmoid函数，该函数的曲线如下所示：</p>
<p><img alt="" src="../img/ch2/2.18/1.jpg" /></p>
<p>如图所示，对0.88和0.98两个点进行比较：
​   假设目标是收敛到1.0。0.88离目标1.0比较远，梯度比较大，权值调整比较大。0.98离目标1.0比较近，梯度比较小，权值调整比较小。调整方案合理。
​   假如目标是收敛到0。0.88离目标0比较近，梯度比较大，权值调整比较大。0.98离目标0比较远，梯度比较小，权值调整比较小。调整方案不合理。
​   原因：在使用sigmoid函数的情况下, 初始的代价（误差）越大，导致训练越慢。</p>
<ol>
<li><strong>交叉熵代价函数（cross-entropy）</strong>：</li>
</ol>
<div>
<div class="MathJax_Preview">
J = -\frac{1}{n}\sum_x[y\ln a + (1-y)\ln{(1-a)}]
</div>
<script type="math/tex; mode=display">
J = -\frac{1}{n}\sum_x[y\ln a + (1-y)\ln{(1-a)}]
</script>
</div>
<p>其中，<span><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>表示代价函数，<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>表示样本，<span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>表示实际值，<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>表示输出值，<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>表示样本的总数。
    权值<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>和偏置<span><span class="MathJax_Preview">b​</span><script type="math/tex">b​</script></span>的梯度推导如下：
$$
\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)
$$</p>
<p>当误差越大时，梯度就越大，权值<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>和偏置<span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>调整就越快，训练的速度也就越快。
<strong>二次代价函数适合输出神经元是线性的情况，交叉熵代价函数适合输出神经元是S型函数的情况。</strong></p>
<ol>
<li><strong>对数似然代价函数（log-likelihood cost）</strong>：
    对数似然函数常用来作为softmax回归的代价函数。深度学习中普遍的做法是将softmax作为最后一层，此时常用的代价函数是对数似然代价函数。
        对数似然代价函数与softmax的组合和交叉熵与sigmoid函数的组合非常相似。对数似然代价函数在二分类时可以化简为交叉熵代价函数的形式。
在tensorflow中：
        与sigmoid搭配使用的交叉熵函数：<code>tf.nn.sigmoid_cross_entropy_with_logits()</code>。
        与softmax搭配使用的交叉熵函数：<code>tf.nn.softmax_cross_entropy_with_logits()</code>。
在pytorch中：
           与sigmoid搭配使用的交叉熵函数：<code>torch.nn.BCEWithLogitsLoss()</code>。
        与softmax搭配使用的交叉熵函数：<code>torch.nn.CrossEntropyLoss()</code>。</li>
</ol>
<h3 id="2105">2.10.5 为什么用交叉熵代替二次代价函数<a class="headerlink" href="#2105" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>为什么不用二次方代价函数</strong>
由上一节可知，权值<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>和偏置<span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>的偏导数为<span><span class="MathJax_Preview">\frac{\partial J}{\partial w}=(a-y)\sigma'(z)x</span><script type="math/tex">\frac{\partial J}{\partial w}=(a-y)\sigma'(z)x</script></span>，<span><span class="MathJax_Preview">\frac{\partial J}{\partial b}=(a-y)\sigma'(z)​</span><script type="math/tex">\frac{\partial J}{\partial b}=(a-y)\sigma'(z)​</script></span>， 偏导数受激活函数的导数影响，sigmoid函数导数在输出接近0和1时非常小，会导致一些实例在刚开始训练时学习得非常慢。</p>
</li>
<li>
<p><strong>为什么要用交叉熵</strong>
交叉熵函数权值<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>和偏置<span><span class="MathJax_Preview">b​</span><script type="math/tex">b​</script></span>的梯度推导为：</p>
</li>
</ol>
<div>
<div class="MathJax_Preview">
\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)
</div>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)
</script>
</div>
<p>由以上公式可知，权重学习的速度受到<span><span class="MathJax_Preview">\sigma{(z)}-y</span><script type="math/tex">\sigma{(z)}-y</script></span>影响，更大的误差，就有更快的学习速度，避免了二次代价函数方程中因<span><span class="MathJax_Preview">\sigma'{(z)}​</span><script type="math/tex">\sigma'{(z)}​</script></span>导致的学习缓慢的情况。</p>
<h2 id="211">2.11 损失函数<a class="headerlink" href="#211" title="Permanent link">&para;</a></h2>
<h3 id="2111">2.11.1 什么是损失函数？<a class="headerlink" href="#2111" title="Permanent link">&para;</a></h3>
<p>​   损失函数（Loss Function）又叫做误差函数，用来衡量算法的运行情况，估量模型的预测值与真实值的不一致程度，是一个非负实值函数，通常使用$
L(Y, f(x))​$来表示。损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数重要组成部分。</p>
<h3 id="2112">2.11.2 常见的损失函数<a class="headerlink" href="#2112" title="Permanent link">&para;</a></h3>
<p>​   机器学习通过对算法中的目标函数进行不断求解优化，得到最终想要的结果。分类和回归问题中，通常使用损失函数或代价函数作为目标函数。
​   损失函数用来评价预测值和真实值不一样的程度。通常损失函数越好，模型的性能也越好。
​   损失函数可分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是在经验风险损失函数上加上正则项。
​   下面介绍常用的损失函数：</p>
<ol>
<li><strong>0-1损失函数</strong>
如果预测值和目标值相等，值为0，如果不相等，值为1。</li>
</ol>
<div>
<div class="MathJax_Preview">
L(Y, f(x)) =
\begin{cases}
1,&amp; Y\ne f(x)\\
0,&amp; Y = f(x)
\end{cases}
</div>
<script type="math/tex; mode=display">
L(Y, f(x)) =
\begin{cases}
1,& Y\ne f(x)\\
0,& Y = f(x)
\end{cases}
</script>
</div>
<p>一般的在实际使用中，相等的条件过于严格，可适当放宽条件：</p>
<div>
<div class="MathJax_Preview">
L(Y, f(x)) =
\begin{cases}
1,&amp; |Y-f(x)|\geqslant T\\
0,&amp; |Y-f(x)|&lt; T
\end{cases}
</div>
<script type="math/tex; mode=display">
L(Y, f(x)) =
\begin{cases}
1,& |Y-f(x)|\geqslant T\\
0,& |Y-f(x)|< T
\end{cases}
</script>
</div>
<ol>
<li><strong>绝对值损失函数</strong>
和0-1损失函数相似，绝对值损失函数表示为：</li>
</ol>
<div>
<div class="MathJax_Preview">
L(Y, f(x)) = |Y-f(x)|​
</div>
<script type="math/tex; mode=display">
L(Y, f(x)) = |Y-f(x)|​
</script>
</div>
<ol>
<li><strong>平方损失函数</strong></li>
</ol>
<div>
<div class="MathJax_Preview">
L(Y, f(x)) = \sum_N{(Y-f(x))}^2
</div>
<script type="math/tex; mode=display">
L(Y, f(x)) = \sum_N{(Y-f(x))}^2
</script>
</div>
<p>这点可从最小二乘法和欧几里得距离角度理解。最小二乘法的原理是，最优拟合曲线应该使所有点到回归直线的距离和最小。</p>
<ol>
<li><strong>对数损失函数</strong></li>
</ol>
<div>
<div class="MathJax_Preview">
L(Y, P(Y|X)) = -\log{P(Y|X)}
</div>
<script type="math/tex; mode=display">
L(Y, P(Y|X)) = -\log{P(Y|X)}
</script>
</div>
<p>​   常见的逻辑回归使用的就是对数损失函数，有很多人认为逻辑回归的损失函数是平方损失，其实不然。逻辑回归它假设样本服从伯努利分布（0-1分布），进而求得满足该分布的似然函数，接着取对数求极值等。逻辑回归推导出的经验风险函数是最小化负的似然函数，从损失函数的角度看，就是对数损失函数。</p>
<ol>
<li><strong>指数损失函数</strong>
指数损失函数的标准形式为：</li>
</ol>
<div>
<div class="MathJax_Preview">
L(Y, f(x)) = \exp(-Yf(x))
</div>
<script type="math/tex; mode=display">
L(Y, f(x)) = \exp(-Yf(x))
</script>
</div>
<p>例如AdaBoost就是以指数损失函数为损失函数。</p>
<ol>
<li><strong>Hinge损失函数</strong>
Hinge损失函数的标准形式如下：</li>
</ol>
<div>
<div class="MathJax_Preview">
L(y) = \max{(0, 1-ty)}
</div>
<script type="math/tex; mode=display">
L(y) = \max{(0, 1-ty)}
</script>
</div>
<p>统一的形式：
$$
L(Y, f(x)) = \max{(0, Yf(x))}
$$</p>
<p>其中y是预测值，范围为(-1,1)，t为目标值，其为-1或1。</p>
<p>在线性支持向量机中，最优化问题可等价于</p>
<div>
<div class="MathJax_Preview">
\underset{\min}{w,b}\sum_{i=1}^N (1-y_i(wx_i+b))+\lambda\Vert w\Vert ^2
</div>
<script type="math/tex; mode=display">
\underset{\min}{w,b}\sum_{i=1}^N (1-y_i(wx_i+b))+\lambda\Vert w\Vert ^2
</script>
</div>
<p>上式相似于下式</p>
<div>
<div class="MathJax_Preview">
\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i) + \Vert w\Vert ^2
</div>
<script type="math/tex; mode=display">
\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i) + \Vert w\Vert ^2
</script>
</div>
<p>其中<span><span class="MathJax_Preview">l(wx_i+by_i)</span><script type="math/tex">l(wx_i+by_i)</script></span>是Hinge损失函数，<span><span class="MathJax_Preview">\Vert w\Vert ^2</span><script type="math/tex">\Vert w\Vert ^2</script></span>可看做为正则化项。</p>
<h3 id="2113">2.11.3 逻辑回归为什么使用对数损失函数？<a class="headerlink" href="#2113" title="Permanent link">&para;</a></h3>
<p>假设逻辑回归模型
$$
P(y=1|x;\theta)=\frac{1}{1+e<sup>{-\theta</sup>{T}x}}
$$
假设逻辑回归模型的概率分布是伯努利分布，其概率质量函数为：
$$
P(X=n)=
\begin{cases}
1-p, n=0\
 p,n=1
\end{cases}
$$
其似然函数为：
$$
L(\theta)=\prod_{i=1}<sup>{m}
P(y=1|x_i)</sup>{y_i}P(y=0|x_i)^{1-y_i}
$$
对数似然函数为：
$$
\ln L(\theta)=\sum_{i=1}^{m}[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln{P(y=0|x_i)}]\
  =\sum_{i=1}<sup>m[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln(1-P(y=1|x_i))]
$$
对数函数在单个数据点上的定义为：
$$
cost(y,p(y|x))=-y\ln{p(y|x)-(1-y)\ln(1-p(y|x))}
$$
则全局样本损失函数为：
$$
cost(y,p(y|x)) = -\sum_{i=1}</sup>m[y_i\ln p(y_i|x_i)+(1-y_i)\ln(1-p(y_i|x_i))]
$$
由此可看出，对数损失函数与极大似然估计的对数似然函数本质上是相同的。所以逻辑回归直接采用对数损失函数。</p>
<h3 id="2114">2.11.4 对数损失函数是如何度量损失的？<a class="headerlink" href="#2114" title="Permanent link">&para;</a></h3>
<p>​   例如，在高斯分布中，我们需要确定均值和标准差。
​   如何确定这两个参数？最大似然估计是比较常用的方法。最大似然的目标是找到一些参数值，这些参数值对应的分布可以最大化观测到数据的概率。
​   因为需要计算观测到所有数据的全概率，即所有观测到的数据点的联合概率。现考虑如下简化情况：</p>
<ol>
<li>假设观测到每个数据点的概率和其他数据点的概率是独立的。</li>
<li>
<p>取自然对数。
     假设观测到单个数据点<span><span class="MathJax_Preview">x_i(i=1,2,...n)</span><script type="math/tex">x_i(i=1,2,...n)</script></span>的概率为：
$$
P(x_i;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp 
        \left( - \frac{(x_i-\mu)<sup>2}{2\sigma</sup>2} \right)
$$</p>
</li>
<li>
<p>其联合概率为：
     $$
     P(x_1,x_2,...,x_n;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp 
            \left( - \frac{(x_1-\mu)<sup>2}{2\sigma</sup>2} \right) \ \times
             \frac{1}{\sigma \sqrt{2\pi}}\exp 
            \left( - \frac{(x_2-\mu)<sup>2}{2\sigma</sup>2} \right) \times ... \times
            \frac{1}{\sigma \sqrt{2\pi}}\exp 
            \left( - \frac{(x_n-\mu)<sup>2}{2\sigma</sup>2} \right)
     $$</p>
</li>
</ol>
<p>​   对上式取自然对数，可得：
$$
 \ln(P(x_1,x_2,...x_n;\mu,\sigma))=
        \ln \left(\frac{1}{\sigma \sqrt{2\pi}} \right) 
         - \frac{(x_1-\mu)<sup>2}{2\sigma</sup>2}  \ +
         \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right) 
         - \frac{(x_2-\mu)<sup>2}{2\sigma</sup>2} +...+
         \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right) 
         - \frac{(x_n-\mu)<sup>2}{2\sigma</sup>2}
$$
根据对数定律，上式可以化简为：
$$
\ln(P(x_1,x_2,...x_n;\mu,\sigma))=-n\ln(\sigma)-\frac{n}{2} \ln(2\pi)\
        -\frac{1}{2\sigma<sup>2}[(x_1-\mu)</sup>2+(x_2-\mu)<sup>2+...+(x_n-\mu)</sup>2]
$$
然后求导为：
$$
\frac{\partial\ln(P(x_1,x_2,...,x_n;\mu,\sigma))}{\partial\mu}=
                \frac{n}{\sigma^2}[\mu - (x_1+x_2+...+x_n)]
$$
​     上式左半部分为对数损失函数。损失函数越小越好，因此我们令等式左半的对数损失函数为0，可得：
$$
\mu=\frac{x_1+x_2+...+x_n}{n}
$$
同理，可计算<span><span class="MathJax_Preview">\sigma ​</span><script type="math/tex">\sigma ​</script></span>。</p>
<h2 id="212">2.12 梯度下降<a class="headerlink" href="#212" title="Permanent link">&para;</a></h2>
<h3 id="2121">2.12.1 机器学习中为什么需要梯度下降？<a class="headerlink" href="#2121" title="Permanent link">&para;</a></h3>
<ol>
<li>梯度下降是迭代法的一种，可以用于求解最小二乘问题。</li>
<li>在求解机器学习算法的模型参数，即无约束优化问题时，主要有梯度下降法（Gradient Descent）和最小二乘法。</li>
<li>在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。</li>
<li>如果我们需要求解损失函数的最大值，可通过梯度上升法来迭代。梯度下降法和梯度上升法可相互转换。</li>
<li>在机器学习中，梯度下降法主要有随机梯度下降法和批量梯度下降法。</li>
</ol>
<h3 id="2122">2.12.2 梯度下降法缺点？<a class="headerlink" href="#2122" title="Permanent link">&para;</a></h3>
<ol>
<li>靠近极小值时收敛速度减慢。</li>
<li>直线搜索时可能会产生一些问题。</li>
<li>可能会“之字形”地下降。</li>
</ol>
<p>梯度概念需注意：
1. 梯度是一个向量，即有方向有大小。 
2. 梯度的方向是最大方向导数的方向。 
3. 梯度的值是最大方向导数的值。</p>
<h3 id="2123">2.12.3 梯度下降法直观理解？<a class="headerlink" href="#2123" title="Permanent link">&para;</a></h3>
<p>梯度下降法经典图示：</p>
<p><img alt="" src="../img/ch2/2.25/1.png" /></p>
<p>​   形象化举例，由上图，假如最开始，我们在一座大山上的某处位置，因为到处都是陌生的，不知道下山的路，所以只能摸索着根据直觉，走一步算一步，在此过程中，每走到一个位置的时候，都会求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。不断循环求梯度，就这样一步步地走下去，一直走到我们觉得已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山势低处。
​   由此，从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部的最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p>
<p><strong>核心思想归纳</strong>：</p>
<ol>
<li>初始化参数，随机选取取值范围内的任意数；</li>
<li>迭代操作：
 a）计算当前梯度；
b）修改新的变量；
c）计算朝最陡的下坡方向走一步；
d）判断是否需要终止，如否，返回a）；</li>
<li>得到全局最优解或者接近全局最优解。</li>
</ol>
<h3 id="2124">2.12.4 梯度下降法算法描述<a class="headerlink" href="#2124" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>确定优化模型的假设函数及损失函数。
    ​   举例，对于线性回归，假设函数为：
$$
  h_\theta(x_1,x_2,...,x_n)=\theta_0+\theta_1x_1+...+\theta_nx_n
$$
  其中，<span><span class="MathJax_Preview">\theta_i,x_i(i=0,1,2,...,n)</span><script type="math/tex">\theta_i,x_i(i=0,1,2,...,n)</script></span>分别为模型参数、每个样本的特征值。
  对于假设函数，损失函数为：
$$
  J(\theta_0,\theta_1,...,\theta_n)=\frac{1}{2m}\sum^{m}<em>{j=0}(h</em>\theta (x^{(j)}_0
    ,x<sup>{(j)}_1,...,x</sup>{(j)}_n)-y_j)^2
$$</p>
</li>
<li>
<p>相关参数初始化。
    ​   主要初始化<span><span class="MathJax_Preview">{\theta}_i</span><script type="math/tex">{\theta}_i</script></span>、算法迭代步长${\alpha} <span><span class="MathJax_Preview">、终止距离</span><script type="math/tex">、终止距离</script></span>{\zeta} <span><span class="MathJax_Preview">。初始化时可以根据经验初始化，即</span><script type="math/tex">。初始化时可以根据经验初始化，即</script></span>{\theta} <span><span class="MathJax_Preview">初始化为0，步长</span><script type="math/tex">初始化为0，步长</script></span>{\alpha} <span><span class="MathJax_Preview">初始化为1。当前步长记为</span><script type="math/tex">初始化为1。当前步长记为</script></span>{\varphi}_i $。当然，也可随机初始化。</p>
</li>
<li>
<p>迭代计算。</p>
<p>1）计算当前位置时损失函数的梯度，对${\theta}_i $，其梯度表示为：</p>
</li>
</ol>
<p>$$
\frac{\partial}{\partial \theta_i}J({\theta}<em>0,{\theta}_1,...,{\theta}_n)=\frac{1}{2m}\sum^{m}</em>{j=0}(h_\theta (x^{(j)}<em>0
    ,x<sup>{(j)}_1,...,x</sup>{(j)}_n)-y_j)^2
$$
​   2）计算当前位置下降的距离。
$$
{\varphi}_i={\alpha} \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)
$$
​   3）判断是否终止。
​   确定是否所有<span><span class="MathJax_Preview">{\theta}_i</span><script type="math/tex">{\theta}_i</script></span>梯度下降的距离<span><span class="MathJax_Preview">{\varphi}_i</span><script type="math/tex">{\varphi}_i</script></span>都小于终止距离<span><span class="MathJax_Preview">{\zeta}</span><script type="math/tex">{\zeta}</script></span>，如果都小于<span><span class="MathJax_Preview">{\zeta}</span><script type="math/tex">{\zeta}</script></span>，则算法终止，当然的值即为最终结果，否则进入下一步。
​   4）更新所有的<span><span class="MathJax_Preview">{\theta}_i</span><script type="math/tex">{\theta}_i</script></span>，更新后的表达式为：
$$
{\theta}_i={\theta}_i-\alpha \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)
$$
$$
\theta_i=\theta_i - \alpha \frac{1}{m} \sum^{m}</em>{j=0}(h_\theta (x^{(j)}_0
    ,x<sup>{(j)}_1,...,x</sup>{(j)}_n)-y_j)x^{(j)}_i
$$
​   5）令上式<span><span class="MathJax_Preview">x^{(j)}_0=1</span><script type="math/tex">x^{(j)}_0=1</script></span>，更新完毕后转入1)。
​   由此，可看出，当前位置的梯度方向由所有样本决定，上式中 <span><span class="MathJax_Preview">\frac{1}{m}​</span><script type="math/tex">\frac{1}{m}​</script></span>、<span><span class="MathJax_Preview">\alpha \frac{1}{m}​</span><script type="math/tex">\alpha \frac{1}{m}​</script></span> 的目的是为了便于理解。</p>
<h3 id="2125">2.12.5 如何对梯度下降法进行调优？<a class="headerlink" href="#2125" title="Permanent link">&para;</a></h3>
<p>实际使用梯度下降法时，各项参数指标不能一步就达到理想状态，对梯度下降法调优主要体现在以下几个方面：
1. <strong>算法迭代步长<span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>选择。</strong>
    在算法参数初始化时，有时根据经验将步长初始化为1。实际取值取决于数据样本。可以从大到小，多取一些值，分别运行算法看迭代效果，如果损失函数在变小，则取值有效。如果取值无效，说明要增大步长。但步长太大，有时会导致迭代速度过快，错过最优解。步长太小，迭代速度慢，算法运行时间长。
2. <strong>参数的初始值选择。</strong>
    初始值不同，获得的最小值也有可能不同，梯度下降有可能得到的是局部最小值。如果损失函数是凸函数，则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。
3. <strong>标准化处理。</strong>
    由于样本不同，特征取值范围也不同，导致迭代速度慢。为了减少特征取值的影响，可对特征数据标准化，使新期望为0，新方差为1，可节省算法运行时间。</p>
<h3 id="2126">2.12.6 随机梯度和批量梯度区别？<a class="headerlink" href="#2126" title="Permanent link">&para;</a></h3>
<p>​   随机梯度下降（SDG）和批量梯度下降（BDG）是两种主要梯度下降法，其目的是增加某些限制来加速运算求解。
下面通过介绍两种梯度下降法的求解思路，对其进行比较。
假设函数为：
$$
h_\theta (x_0,x_1,...,x_3) = \theta_0 x_0 + \theta_1 x_1 + ... + \theta_n x_n
$$
损失函数为：
$$
J(\theta_0, \theta_1, ... , \theta_n) = 
            \frac{1}{2m} \sum^{m}<em>{j=0}(h</em>\theta (x^{j}_0
    ,x<sup>{j}_1,...,x</sup>{j}_n)-y<sup>j)</sup>2
$$
其中，<span><span class="MathJax_Preview">m​</span><script type="math/tex">m​</script></span>为样本个数，<span><span class="MathJax_Preview">j​</span><script type="math/tex">j​</script></span>为参数个数。</p>
<p>1、 <strong>批量梯度下降的求解思路如下：</strong>
a) 得到每个$ \theta ​$对应的梯度：
$$
\frac{\partial}{\partial \theta_i}J({\theta}<em>0,{\theta}_1,...,{\theta}_n)=\frac{1}{m}\sum^{m}</em>{j=0}(h_\theta (x^{j}<em>0
    ,x<sup>{j}_1,...,x</sup>{j}_n)-y<sup>j)x</sup>{j}_i
$$
b) 由于是求最小化风险函数，所以按每个参数 $ \theta ​$ 的梯度负方向更新 $ \theta_i ​$ ：
$$
\theta_i=\theta_i - \frac{1}{m} \sum^{m}</em>{j=0}(h_\theta (x^{j}_0
    ,x<sup>{j}_1,...,x</sup>{j}_n)-y<sup>j)x</sup>{j}_i
$$
c) 从上式可以注意到，它得到的虽然是一个全局最优解，但每迭代一步，都要用到训练集所有的数据，如果样本数据很大，这种方法迭代速度就很慢。
相比而言，随机梯度下降可避免这种问题。</p>
<p>2、<strong>随机梯度下降的求解思路如下：</strong>
a) 相比批量梯度下降对应所有的训练样本，随机梯度下降法中损失函数对应的是训练集中每个样本的粒度。
损失函数可以写成如下这种形式，
$$
J(\theta_0, \theta_1, ... , \theta_n) = 
            \frac{1}{m} \sum<sup>{m}_{j=0}(y</sup>j - h_\theta (x^{j}<em>0
            ,x<sup>{j}_1,...,x</sup>{j}_n))^2 = 
            \frac{1}{m} \sum^{m}</em>{j=0} cost(\theta,(x<sup>j,y</sup>j))
$$
b）对每个参数 $ \theta​$ 按梯度方向更新 $ \theta​$：
$$
\theta_i = \theta_i + (y^j - h_\theta (x^{j}_0, x^{j}_1, ... ,x^{j}_n))
$$
c) 随机梯度下降是通过每个样本来迭代更新一次。
随机梯度下降伴随的一个问题是噪音较批量梯度下降要多，使得随机梯度下降并不是每次迭代都向着整体最优化方向。</p>
<p><strong>小结：</strong>
随机梯度下降法、批量梯度下降法相对来说都比较极端，简单对比如下：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">批量梯度下降</td>
<td align="left">a）采用所有数据来梯度下降。<br/>b）批量梯度下降法在样本量很大的时候，训练速度慢。</td>
</tr>
<tr>
<td align="center">随机梯度下降</td>
<td align="left">a）随机梯度下降用一个样本来梯度下降。<br/>b）训练速度很快。<br />c）随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br />d）收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</td>
</tr>
</tbody>
</table>
<p>下面介绍能结合两种方法优点的小批量梯度下降法。</p>
<p>3、 <strong>小批量（Mini-Batch）梯度下降的求解思路如下</strong>
对于总数为<span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>个样本的数据，根据样本的数据，选取其中的<span><span class="MathJax_Preview">n(1&lt; n&lt; m)</span><script type="math/tex">n(1< n< m)</script></span>个子样本来迭代。其参数<span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>按梯度方向更新<span><span class="MathJax_Preview">\theta_i</span><script type="math/tex">\theta_i</script></span>公式如下：
$$
\theta_i = \theta_i - \alpha \sum^{t+n-1}<em>{j=t}
        ( h</em>\theta (x^{j}<em>{0}, x^{j}</em>{1}, ... , x^{j}<em>{n} ) - y^j ) x^{j}</em>{i}
$$</p>
<h3 id="2127">2.12.7 各种梯度下降法性能比较<a class="headerlink" href="#2127" title="Permanent link">&para;</a></h3>
<p>​   下表简单对比随机梯度下降（SGD）、批量梯度下降（BGD）、小批量梯度下降（Mini-batch GD）、和Online GD的区别：</p>
<p>||BGD|SGD|Mini-batch GD|Online GD|
|:-:|:-:|:-:|:-:|:-:|:-:|
|训练集|固定|固定|固定|实时更新|
|单次迭代样本数|整个训练集|单个样本|训练集的子集|根据具体算法定|
|算法复杂度|高|低|一般|低|
|时效性|低|一般|一般|高|
|收敛性|稳定|不稳定|较稳定|不稳定|</p>
<p>BGD、SGD、Mini-batch GD，前面均已讨论过，这里介绍一下Online GD。</p>
<p>​   Online GD于Mini-batch GD/SGD的区别在于，所有训练数据只用一次，然后丢弃。这样做的优点在于可预测最终模型的变化趋势。</p>
<p>​   Online GD在互联网领域用的较多，比如搜索广告的点击率（CTR）预估模型，网民的点击行为会随着时间改变。用普通的BGD算法（每天更新一次）一方面耗时较长（需要对所有历史数据重新训练）；另一方面，无法及时反馈用户的点击行为迁移。而Online GD算法可以实时的依据网民的点击行为进行迁移。</p>
<h2 id="213">2.13 计算图的导数计算？<a class="headerlink" href="#213" title="Permanent link">&para;</a></h2>
<p>​   计算图导数计算是反向传播，利用链式法则和隐式函数求导。</p>
<p>​   假设 <span><span class="MathJax_Preview">z = f(u,v)</span><script type="math/tex">z = f(u,v)</script></span> 在点 <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> 处偏导连续，<span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span>是关于 <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 的函数，在 <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 点可导，求 <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> 在 <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 点的导数。</p>
<p>根据链式法则有
$$
\frac{dz}{dt}=\frac{\partial z}{\partial u}.\frac{du}{dt}+\frac{\partial z}{\partial v}
                .\frac{dv}{dt}
$$</p>
<p>​   链式法则用文字描述:“由两个函数凑起来的复合函数，其导数等于里边函数代入外边函数的值之导数，乘以里边函数的导数。<br />
​   为了便于理解，下面举例说明：</p>
<div>
<div class="MathJax_Preview">
f(x)=x^2,g(x)=2x+1
</div>
<script type="math/tex; mode=display">
f(x)=x^2,g(x)=2x+1
</script>
</div>
<p>​   则:
$$
{f[g(x)]}'=2[g(x)] \times g'(x)=2[2x+1] \times 2=8x+4
$$</p>
<h2 id="214-lda">2.14 线性判别分析（LDA）<a class="headerlink" href="#214-lda" title="Permanent link">&para;</a></h2>
<h3 id="2141-lda">2.14.1 LDA思想总结<a class="headerlink" href="#2141-lda" title="Permanent link">&para;</a></h3>
<p>​   线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的降维方法。和主成分分析PCA不考虑样本类别输出的无监督降维技术不同，LDA是一种监督学习的降维技术，数据集的每个样本有类别输出。  </p>
<p>LDA分类思想简单总结如下：<br />
1. 多维空间中，数据处理分类问题较为复杂，LDA算法将多维空间中的数据投影到一条直线上，将d维数据转化成1维数据进行处理。<br />
2. 对于训练数据，设法将多维数据投影到一条直线上，同类数据的投影点尽可能接近，异类数据点尽可能远离。<br />
3. 对数据进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。  </p>
<p>如果用一句话概括LDA思想，即“投影后类内方差最小，类间方差最大”。</p>
<h3 id="2142-lda">2.14.2 图解LDA核心思想<a class="headerlink" href="#2142-lda" title="Permanent link">&para;</a></h3>
<p>​   假设有红、蓝两类数据，这些数据特征均为二维，如下图所示。我们的目标是将这些数据投影到一维，让每一类相近的数据的投影点尽可能接近，不同类别数据尽可能远，即图中红色和蓝色数据中心之间的距离尽可能大。</p>
<p><img alt="" src="../img/ch2/2.29/1.png" /></p>
<p>左图和右图是两种不同的投影方式。</p>
<p>​   左图思路：让不同类别的平均点距离最远的投影方式。</p>
<p>​   右图思路：让同类别的数据挨得最近的投影方式。</p>
<p>​   从上图直观看出，右图红色数据和蓝色数据在各自的区域来说相对集中，根据数据分布直方图也可看出，所以右图的投影效果好于左图，左图中间直方图部分有明显交集。</p>
<p>​   以上例子是基于数据是二维的，分类后的投影是一条直线。如果原始数据是多维的，则投影后的分类面是一低维的超平面。</p>
<h3 id="2143-lda">2.14.3 二类LDA算法原理？<a class="headerlink" href="#2143-lda" title="Permanent link">&para;</a></h3>
<p>​   输入：数据集 <span><span class="MathJax_Preview">D=\{(\boldsymbol x_1,\boldsymbol y_1),(\boldsymbol x_2,\boldsymbol y_2),...,(\boldsymbol x_m,\boldsymbol y_m)\}​</span><script type="math/tex">D=\{(\boldsymbol x_1,\boldsymbol y_1),(\boldsymbol x_2,\boldsymbol y_2),...,(\boldsymbol x_m,\boldsymbol y_m)\}​</script></span>，其中样本 <span><span class="MathJax_Preview">\boldsymbol x_i ​</span><script type="math/tex">\boldsymbol x_i ​</script></span> 是n维向量，<span><span class="MathJax_Preview">\boldsymbol y_i  \epsilon \{0, 1\}​</span><script type="math/tex">\boldsymbol y_i  \epsilon \{0, 1\}​</script></span>，降维后的目标维度 <span><span class="MathJax_Preview">d​</span><script type="math/tex">d​</script></span>。定义</p>
<p>​   <span><span class="MathJax_Preview">N_j(j=0,1)</span><script type="math/tex">N_j(j=0,1)</script></span> 为第 <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 类样本个数；</p>
<p>​   <span><span class="MathJax_Preview">X_j(j=0,1)</span><script type="math/tex">X_j(j=0,1)</script></span> 为第 <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 类样本的集合；</p>
<p>​   <span><span class="MathJax_Preview">u_j(j=0,1)​</span><script type="math/tex">u_j(j=0,1)​</script></span> 为第 <span><span class="MathJax_Preview">j​</span><script type="math/tex">j​</script></span> 类样本的均值向量；</p>
<p>​   <span><span class="MathJax_Preview">\sum_j(j=0,1)</span><script type="math/tex">\sum_j(j=0,1)</script></span> 为第 <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 类样本的协方差矩阵。</p>
<p>​   其中
$$
u_j = \frac{1}{N_j} \sum_{\boldsymbol x\epsilon X_j}\boldsymbol x(j=0,1)， 
\sum_j = \sum_{\boldsymbol x\epsilon X_j}(\boldsymbol x-u_j)(\boldsymbol x-u_j)^T(j=0,1)
$$
​   假设投影直线是向量 <span><span class="MathJax_Preview">\boldsymbol w</span><script type="math/tex">\boldsymbol w</script></span>，对任意样本 <span><span class="MathJax_Preview">\boldsymbol x_i</span><script type="math/tex">\boldsymbol x_i</script></span>，它在直线 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>上的投影为 <span><span class="MathJax_Preview">\boldsymbol w^Tx_i</span><script type="math/tex">\boldsymbol w^Tx_i</script></span>，两个类别的中心点 <span><span class="MathJax_Preview">u_0</span><script type="math/tex">u_0</script></span>, <span><span class="MathJax_Preview">u_1 <span><span class="MathJax_Preview">在直线 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> 的投影分别为  的投影分别为 <span><span class="MathJax_Preview">\boldsymbol w^Tu_0</span><script type="math/tex">\boldsymbol w^Tu_0</script></span> 、 、</span><script type="math/tex">在直线 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> 的投影分别为  的投影分别为 <span><span class="MathJax_Preview">\boldsymbol w^Tu_0</span><script type="math/tex">\boldsymbol w^Tu_0</script></span> 、 、</script></span>\boldsymbol w^Tu_1\boldsymbol w^Tu_1</span><script type="math/tex">u_1 <span><span class="MathJax_Preview">在直线 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> 的投影分别为  的投影分别为 <span><span class="MathJax_Preview">\boldsymbol w^Tu_0</span><script type="math/tex">\boldsymbol w^Tu_0</script></span> 、 、</span><script type="math/tex">在直线 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> 的投影分别为  的投影分别为 <span><span class="MathJax_Preview">\boldsymbol w^Tu_0</span><script type="math/tex">\boldsymbol w^Tu_0</script></span> 、 、</script></span>\boldsymbol w^Tu_1\boldsymbol w^Tu_1</script></span>。</p>
<p>​   LDA的目标是让两类别的数据中心间的距离 <span><span class="MathJax_Preview">\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2</span><script type="math/tex">\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2</script></span> 尽量大，与此同时，希望同类样本投影点的协方差<span><span class="MathJax_Preview">\boldsymbol w^T \sum_0 \boldsymbol w</span><script type="math/tex">\boldsymbol w^T \sum_0 \boldsymbol w</script></span>、<span><span class="MathJax_Preview">\boldsymbol w^T \sum_1 \boldsymbol w</span><script type="math/tex">\boldsymbol w^T \sum_1 \boldsymbol w</script></span> 尽量小，最小化 <span><span class="MathJax_Preview">\boldsymbol w^T \sum_0 \boldsymbol w - \boldsymbol w^T \sum_1 \boldsymbol w​</span><script type="math/tex">\boldsymbol w^T \sum_0 \boldsymbol w - \boldsymbol w^T \sum_1 \boldsymbol w​</script></span> 。
​   定义
​   类内散度矩阵
$$
S_w = \sum_0 + \sum_1 = 
    \sum_{\boldsymbol x\epsilon X_0}(\boldsymbol x-u_0)(\boldsymbol x-u_0)^T + 
    \sum_{\boldsymbol x\epsilon X_1}(\boldsymbol x-u_1)(\boldsymbol x-u_1)^T
$$
​   类间散度矩阵 <span><span class="MathJax_Preview">S_b = (u_0 - u_1)(u_0 - u_1)^T</span><script type="math/tex">S_b = (u_0 - u_1)(u_0 - u_1)^T</script></span></p>
<p>​   据上分析，优化目标为
$$
\mathop{\arg\max}_\boldsymbol w J(\boldsymbol w) = \frac{| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 |^2_2}{\boldsymbol w^T \sum_0\boldsymbol w + \boldsymbol w^T \sum_1\boldsymbol w} = 
\frac{\boldsymbol w<sup>T(u_0-u_1)(u_0-u_1)</sup>T\boldsymbol w}{\boldsymbol w^T(\sum_0 + \sum_1)\boldsymbol w} =
\frac{\boldsymbol w^TS_b\boldsymbol w}{\boldsymbol w^TS_w\boldsymbol w}
$$
​   根据广义瑞利商的性质，矩阵 <span><span class="MathJax_Preview">S^{-1}_{w} S_b</span><script type="math/tex">S^{-1}_{w} S_b</script></span> 的最大特征值为 <span><span class="MathJax_Preview">J(\boldsymbol w)</span><script type="math/tex">J(\boldsymbol w)</script></span> 的最大值，矩阵 <span><span class="MathJax_Preview">S^{-1}_{w} S_b</span><script type="math/tex">S^{-1}_{w} S_b</script></span> 的最大特征值对应的特征向量即为 <span><span class="MathJax_Preview">\boldsymbol w</span><script type="math/tex">\boldsymbol w</script></span>。</p>
<h3 id="2144-lda">2.14.4 LDA算法流程总结？<a class="headerlink" href="#2144-lda" title="Permanent link">&para;</a></h3>
<p>LDA算法降维流程如下：</p>
<p>​   输入：数据集 <span><span class="MathJax_Preview">D = \{ (x_1,y_1),(x_2,y_2), ... ,(x_m,y_m) \}</span><script type="math/tex">D = \{ (x_1,y_1),(x_2,y_2), ... ,(x_m,y_m) \}</script></span>，其中样本 $x_i $ 是n维向量，<span><span class="MathJax_Preview">y_i  \epsilon \{C_1, C_2, ..., C_k\}</span><script type="math/tex">y_i  \epsilon \{C_1, C_2, ..., C_k\}</script></span>，降维后的目标维度 <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> 。</p>
<p>​   输出：降维后的数据集 $\overline{D} $ 。</p>
<p>步骤：
1. 计算类内散度矩阵 <span><span class="MathJax_Preview">S_w</span><script type="math/tex">S_w</script></span>。
2. 计算类间散度矩阵 <span><span class="MathJax_Preview">S_b​</span><script type="math/tex">S_b​</script></span> 。
3. 计算矩阵 <span><span class="MathJax_Preview">S^{-1}_wS_b​</span><script type="math/tex">S^{-1}_wS_b​</script></span> 。
4. 计算矩阵 <span><span class="MathJax_Preview">S^{-1}_wS_b</span><script type="math/tex">S^{-1}_wS_b</script></span> 的最大的 d 个特征值。
5. 计算 d 个特征值对应的 d 个特征向量，记投影矩阵为 W 。
6. 转化样本集的每个样本，得到新样本 <span><span class="MathJax_Preview">P_i = W^Tx_i​</span><script type="math/tex">P_i = W^Tx_i​</script></span> 。
7. 输出新样本集 <span><span class="MathJax_Preview">\overline{D} = \{ (p_1,y_1),(p_2,y_2),...,(p_m,y_m) \}​</span><script type="math/tex">\overline{D} = \{ (p_1,y_1),(p_2,y_2),...,(p_m,y_m) \}​</script></span></p>
<h3 id="2145-ldapca">2.14.5 LDA和PCA区别？<a class="headerlink" href="#2145-ldapca" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">异同点</th>
<th align="left">LDA</th>
<th align="left">PCA</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">相同点</td>
<td align="left">1. 两者均可以对数据进行降维；<br />2. 两者在降维时均使用了矩阵特征分解的思想；<br />3. 两者都假设数据符合高斯分布；</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">不同点</td>
<td align="left">有监督的降维方法；</td>
<td align="left">无监督的降维方法；</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">降维最多降到k-1维；</td>
<td align="left">降维多少没有限制；</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">可以用于降维，还可以用于分类；</td>
<td align="left">只用于降维；</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">选择分类性能最好的投影方向；</td>
<td align="left">选择样本点投影具有最大方差的方向；</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">更明确，更能反映样本间差异；</td>
<td align="left">目的较为模糊；</td>
</tr>
</tbody>
</table>
<h3 id="2146-lda">2.14.6 LDA优缺点？<a class="headerlink" href="#2146-lda" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">优缺点</th>
<th align="left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">优点</td>
<td align="left">1. 可以使用类别的先验知识；<br />2. 以标签、类别衡量差异性的有监督降维方式，相对于PCA的模糊性，其目的更明确，更能反映样本间的差异；</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">1. LDA不适合对非高斯分布样本进行降维；<br />2. LDA降维最多降到分类数k-1维；<br />3. LDA在样本分类信息依赖方差而不是均值时，降维效果不好；<br />4. LDA可能过度拟合数据。</td>
</tr>
</tbody>
</table>
<h2 id="215-pca">2.15  主成分分析（PCA）<a class="headerlink" href="#215-pca" title="Permanent link">&para;</a></h2>
<h3 id="2151-pca">2.15.1 主成分分析（PCA）思想总结<a class="headerlink" href="#2151-pca" title="Permanent link">&para;</a></h3>
<ol>
<li>PCA就是将高维的数据通过线性变换投影到低维空间上去。</li>
<li>投影思想：找出最能够代表原始数据的投影方法。被PCA降掉的那些维度只能是那些噪声或是冗余的数据。</li>
<li>去冗余：去除可以被其他向量代表的线性相关向量，这部分信息量是多余的。</li>
<li>去噪声，去除较小特征值对应的特征向量，特征值的大小反映了变换后在特征向量方向上变换的幅度，幅度越大，说明这个方向上的元素差异也越大，要保留。</li>
<li>对角化矩阵，寻找极大线性无关组，保留较大的特征值，去除较小特征值，组成一个投影矩阵，对原始样本矩阵进行投影，得到降维后的新样本矩阵。</li>
<li>完成PCA的关键是——协方差矩阵。协方差矩阵，能同时表现不同维度间的相关性以及各个维度上的方差。协方差矩阵度量的是维度与维度之间的关系，而非样本与样本之间。</li>
<li>之所以对角化，因为对角化之后非对角上的元素都是0，达到去噪声的目的。对角化后的协方差矩阵，对角线上较小的新方差对应的就是那些该去掉的维度。所以我们只取那些含有较大能量(特征值)的维度，其余的就舍掉，即去冗余。</li>
</ol>
<h3 id="2152-pca">2.15.2 图解PCA核心思想<a class="headerlink" href="#2152-pca" title="Permanent link">&para;</a></h3>
<p>​   PCA可解决训练数据中存在数据特征过多或特征累赘的问题。核心思想是将m维特征映射到n维（n &lt; m），这n维形成主元，是重构出来最能代表原始数据的正交特征。</p>
<p>​   假设数据集是m个n维，<span><span class="MathJax_Preview">(\boldsymbol x^{(1)}, \boldsymbol x^{(2)}, \cdots, \boldsymbol x^{(m)})</span><script type="math/tex">(\boldsymbol x^{(1)}, \boldsymbol x^{(2)}, \cdots, \boldsymbol x^{(m)})</script></span>。如果<span><span class="MathJax_Preview">n=2</span><script type="math/tex">n=2</script></span>，需要降维到<span><span class="MathJax_Preview">n'=1</span><script type="math/tex">n'=1</script></span>，现在想找到某一维度方向代表这两个维度的数据。下图有<span><span class="MathJax_Preview">u_1, u_2</span><script type="math/tex">u_1, u_2</script></span>两个向量方向，但是哪个向量才是我们所想要的，可以更好代表原始数据集的呢？</p>
<p><img alt="" src="../img/ch2/2.34/1.png" /></p>
<p>从图可看出，<span><span class="MathJax_Preview">u_1</span><script type="math/tex">u_1</script></span>比<span><span class="MathJax_Preview">u_2</span><script type="math/tex">u_2</script></span>好，为什么呢？有以下两个主要评价指标：
1. 样本点到这个直线的距离足够近。
2. 样本点在这个直线上的投影能尽可能的分开。</p>
<p>如果我们需要降维的目标维数是其他任意维，则：
1. 样本点到这个超平面的距离足够近。
2. 样本点在这个超平面上的投影能尽可能的分开。</p>
<h3 id="2153-pca">2.15.3 PCA算法推理<a class="headerlink" href="#2153-pca" title="Permanent link">&para;</a></h3>
<p>下面以基于最小投影距离为评价指标推理：</p>
<p>​   假设数据集是m个n维，<span><span class="MathJax_Preview">(x^{(1)}, x^{(2)},...,x^{(m)})</span><script type="math/tex">(x^{(1)}, x^{(2)},...,x^{(m)})</script></span>，且数据进行了中心化。经过投影变换得到新坐标为 <span><span class="MathJax_Preview">{w_1,w_2,...,w_n}</span><script type="math/tex">{w_1,w_2,...,w_n}</script></span>，其中 <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> 是标准正交基，即 <span><span class="MathJax_Preview">\| w \|_2 = 1</span><script type="math/tex">\| w \|_2 = 1</script></span>，<span><span class="MathJax_Preview">w^T_iw_j = 0</span><script type="math/tex">w^T_iw_j = 0</script></span>。</p>
<p>​   经过降维后，新坐标为 <span><span class="MathJax_Preview">\{ w_1,w_2,...,w_n \}</span><script type="math/tex">\{ w_1,w_2,...,w_n \}</script></span>，其中 <span><span class="MathJax_Preview">n'</span><script type="math/tex">n'</script></span> 是降维后的目标维数。样本点 <span><span class="MathJax_Preview">x^{(i)}</span><script type="math/tex">x^{(i)}</script></span> 在新坐标系下的投影为 <span><span class="MathJax_Preview">z^{(i)} = \left(z^{(i)}_1, z^{(i)}_2, ..., z^{(i)}_{n'}   \right)</span><script type="math/tex">z^{(i)} = \left(z^{(i)}_1, z^{(i)}_2, ..., z^{(i)}_{n'}   \right)</script></span>，其中 <span><span class="MathJax_Preview">z^{(i)}_j = w^T_j x^{(i)}</span><script type="math/tex">z^{(i)}_j = w^T_j x^{(i)}</script></span> 是 <span><span class="MathJax_Preview">x^{(i)} ​</span><script type="math/tex">x^{(i)} ​</script></span> 在低维坐标系里第 j 维的坐标。</p>
<p>​   如果用 $z^{(i)} $ 去恢复 $x^{(i)} $ ，则得到的恢复数据为 <span><span class="MathJax_Preview">\widehat{x}^{(i)} = \sum^{n'}_{j=1} x^{(i)}_j w_j = Wz^{(i)}</span><script type="math/tex">\widehat{x}^{(i)} = \sum^{n'}_{j=1} x^{(i)}_j w_j = Wz^{(i)}</script></span>，其中 <span><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span>为标准正交基组成的矩阵。</p>
<p>​   考虑到整个样本集，样本点到这个超平面的距离足够近，目标变为最小化 <span><span class="MathJax_Preview">\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2</span><script type="math/tex">\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2</script></span> 。对此式进行推理，可得：
$$
\sum^m_{i=1} | \hat{x}^{(i)} - x^{(i)} |^2_2 = 
    \sum^m_{i=1} | Wz^{(i)} - x^{(i)} |^2_2 \
    = \sum^m_{i=1} \left( Wz^{(i)} \right)^T \left( Wz^{(i)} \right)
    - 2\sum^m_{i=1} \left( Wz^{(i)} \right)^T x^{(i)}
    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \
    = \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)
    - 2\sum^m_{i=1} \left( z^{(i)} \right)^T x^{(i)}
    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \
    = - \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)
    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \
    = -tr \left( W^T \left( \sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T \right)W \right)
    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \
    = -tr \left( W<sup>TXX</sup>TW \right)
    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)}
$$</p>
<p>​   在推导过程中，分别用到了 <span><span class="MathJax_Preview">\overline{x}^{(i)} = Wz^{(i)}</span><script type="math/tex">\overline{x}^{(i)} = Wz^{(i)}</script></span> ，矩阵转置公式 <span><span class="MathJax_Preview">(AB)^T = B^TA^T</span><script type="math/tex">(AB)^T = B^TA^T</script></span>，<span><span class="MathJax_Preview">W^TW = I</span><script type="math/tex">W^TW = I</script></span>，<span><span class="MathJax_Preview">z^{(i)} = W^Tx^{(i)}</span><script type="math/tex">z^{(i)} = W^Tx^{(i)}</script></span> 以及矩阵的迹，最后两步是将代数和转为矩阵形式。
​   由于 <span><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span> 的每一个向量 <span><span class="MathJax_Preview">w_j</span><script type="math/tex">w_j</script></span> 是标准正交基，<span><span class="MathJax_Preview">\sum^m_{i=1} x^{(i)} \left(  x^{(i)} \right)^T</span><script type="math/tex">\sum^m_{i=1} x^{(i)} \left(  x^{(i)} \right)^T</script></span> 是数据集的协方差矩阵，$\sum^m_{i=1} \left(  x^{(i)} \right)^T x^{(i)} $ 是一个常量。最小化 <span><span class="MathJax_Preview">\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2</span><script type="math/tex">\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2</script></span> 又可等价于
$$
\underbrace{\arg \min}_W - tr \left( W<sup>TXX</sup>TW \right) s.t.W<sup>TW = I
$$
利用拉格朗日函数可得到
$$
J(W) = -tr(W</sup>TXX^TW) + \lambda(W^TW - I)
$$
​   对 <span><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span> 求导，可得 $-XX^TW + \lambda W = 0 $ ，也即 $ XX^TW = \lambda W $ 。 $ XX^T $ 是 $ n' $ 个特征向量组成的矩阵，<span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> 为$ XX^T $ 的特征值。<span><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span> 即为我们想要的矩阵。
​   对于原始数据，只需要 <span><span class="MathJax_Preview">z^{(i)} = W^TX^{(i)}</span><script type="math/tex">z^{(i)} = W^TX^{(i)}</script></span> ，就可把原始数据集降维到最小投影距离的 <span><span class="MathJax_Preview">n'</span><script type="math/tex">n'</script></span> 维数据集。</p>
<p>​   基于最大投影方差的推导，这里就不再赘述，有兴趣的同仁可自行查阅资料。</p>
<h3 id="2154-pca">2.15.4 PCA算法流程总结<a class="headerlink" href="#2154-pca" title="Permanent link">&para;</a></h3>
<p>输入：<span><span class="MathJax_Preview">n​</span><script type="math/tex">n​</script></span> 维样本集 <span><span class="MathJax_Preview">D = \left( x^{(1)},x^{(2)},...,x^{(m)} \right)​</span><script type="math/tex">D = \left( x^{(1)},x^{(2)},...,x^{(m)} \right)​</script></span> ，目标降维的维数 <span><span class="MathJax_Preview">n'​</span><script type="math/tex">n'​</script></span> 。</p>
<p>输出：降维后的新样本集 <span><span class="MathJax_Preview">D'  = \left( z^{(1)},z^{(2)},...,z^{(m)} \right)</span><script type="math/tex">D'  = \left( z^{(1)},z^{(2)},...,z^{(m)} \right)</script></span> 。</p>
<p>主要步骤如下：
1. 对所有的样本进行中心化，$ x<sup>{(i)} = x</sup>{(i)} - \frac{1}{m} \sum^m_{j=1} x^{(j)} $ 。
2. 计算样本的协方差矩阵 <span><span class="MathJax_Preview">XX^T​</span><script type="math/tex">XX^T​</script></span> 。
3. 对协方差矩阵 <span><span class="MathJax_Preview">XX^T</span><script type="math/tex">XX^T</script></span> 进行特征值分解。
4. 取出最大的 $n' $ 个特征值对应的特征向量 <span><span class="MathJax_Preview">\{ w_1,w_2,...,w_{n'} \}</span><script type="math/tex">\{ w_1,w_2,...,w_{n'} \}</script></span> 。
5. 标准化特征向量，得到特征向量矩阵 <span><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span> 。
6. 转化样本集中的每个样本 <span><span class="MathJax_Preview">z^{(i)} = W^T x^{(i)}</span><script type="math/tex">z^{(i)} = W^T x^{(i)}</script></span> 。
7. 得到输出矩阵 <span><span class="MathJax_Preview">D' = \left( z^{(1)},z^{(2)},...,z^{(n)} \right)​</span><script type="math/tex">D' = \left( z^{(1)},z^{(2)},...,z^{(n)} \right)​</script></span> 。
<em>注</em>：在降维时，有时不明确目标维数，而是指定降维到的主成分比重阈值 <span><span class="MathJax_Preview">k(k \epsilon(0,1])​</span><script type="math/tex">k(k \epsilon(0,1])​</script></span> 。假设 <span><span class="MathJax_Preview">n​</span><script type="math/tex">n​</script></span> 个特征值为 <span><span class="MathJax_Preview">\lambda_1 \geqslant \lambda_2 \geqslant ... \geqslant \lambda_n​</span><script type="math/tex">\lambda_1 \geqslant \lambda_2 \geqslant ... \geqslant \lambda_n​</script></span> ，则 <span><span class="MathJax_Preview">n'​</span><script type="math/tex">n'​</script></span> 可从 <span><span class="MathJax_Preview">\sum^{n'}_{i=1} \lambda_i \geqslant k \times \sum^n_{i=1} \lambda_i ​</span><script type="math/tex">\sum^{n'}_{i=1} \lambda_i \geqslant k \times \sum^n_{i=1} \lambda_i ​</script></span> 得到。</p>
<h3 id="2155-pca">2.15.5 PCA算法主要优缺点<a class="headerlink" href="#2155-pca" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">优缺点</th>
<th align="left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">优点</td>
<td align="left">1. 仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　2.各主成分之间正交，可消除原始数据成分间的相互影响的因素。3. 计算方法简单，主要运算是特征值分解，易于实现。</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">1.主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。2. 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</td>
</tr>
</tbody>
</table>
<h3 id="2156">2.15.6 降维的必要性及目的<a class="headerlink" href="#2156" title="Permanent link">&para;</a></h3>
<p><strong>降维的必要性</strong>：
1. 多重共线性和预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。
2. 高维空间本身具有稀疏性。一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有2%。
3. 过多的变量，对查找规律造成冗余麻烦。
4. 仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。</p>
<p><strong>降维的目的</strong>：
1. 减少预测变量的个数。
2. 确保这些变量是相互独立的。
3. 提供一个框架来解释结果。相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示。
4. 数据在低维下更容易处理、更容易使用。
5. 去除数据噪声。
6. 降低算法运算开销。</p>
<h3 id="2157-kpcapca">2.15.7 KPCA与PCA的区别？<a class="headerlink" href="#2157-kpcapca" title="Permanent link">&para;</a></h3>
<p>​   应用PCA算法前提是假设存在一个线性超平面，进而投影。那如果数据不是线性的呢？该怎么办？这时候就需要KPCA，数据集从 <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 维映射到线性可分的高维 <span><span class="MathJax_Preview">N &gt;n</span><script type="math/tex">N >n</script></span>，然后再从 <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 维降维到一个低维度 <span><span class="MathJax_Preview">n'(n'&lt;n&lt;N)</span><script type="math/tex">n'(n'<n<N)</script></span> 。</p>
<p>​   KPCA用到了核函数思想，使用了核函数的主成分分析一般称为核主成分分析(Kernelized PCA, 简称KPCA）。</p>
<p>假设高维空间数据由 <span><span class="MathJax_Preview">n​</span><script type="math/tex">n​</script></span> 维空间的数据通过映射 <span><span class="MathJax_Preview">\phi​</span><script type="math/tex">\phi​</script></span> 产生。</p>
<p>​   <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 维空间的特征分解为：
$$
\sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T W = \lambda W
$$</p>
<p>​   其映射为
$$
\sum^m_{i=1} \phi \left( x^{(i)} \right) \phi \left( x^{(i)} \right)^T W = \lambda W
$$</p>
<p>​   通过在高维空间进行协方差矩阵的特征值分解，然后用和PCA一样的方法进行降维。由于KPCA需要核函数的运算，因此它的计算量要比PCA大很多。</p>
<h2 id="216">2.16 模型评估<a class="headerlink" href="#216" title="Permanent link">&para;</a></h2>
<h3 id="2161">2.16.1 模型评估常用方法？<a class="headerlink" href="#2161" title="Permanent link">&para;</a></h3>
<p>​   一般情况来说，单一评分标准无法完全评估一个机器学习模型。只用good和bad偏离真实场景去评估某个模型，都是一种欠妥的评估方式。下面介绍常用的分类模型和回归模型评估方法。</p>
<p><strong>分类模型常用评估方法：</strong></p>
<table>
<thead>
<tr>
<th align="center">指标</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Accuracy</td>
<td align="center">准确率</td>
</tr>
<tr>
<td align="center">Precision</td>
<td align="center">精准度/查准率</td>
</tr>
<tr>
<td align="center">Recall</td>
<td align="center">召回率/查全率</td>
</tr>
<tr>
<td align="center">P-R曲线</td>
<td align="center">查准率为纵轴，查全率为横轴，作图</td>
</tr>
<tr>
<td align="center">F1</td>
<td align="center">F1值</td>
</tr>
<tr>
<td align="center">Confusion Matrix</td>
<td align="center">混淆矩阵</td>
</tr>
<tr>
<td align="center">ROC</td>
<td align="center">ROC曲线</td>
</tr>
<tr>
<td align="center">AUC</td>
<td align="center">ROC曲线下的面积</td>
</tr>
</tbody>
</table>
<p><strong>回归模型常用评估方法：</strong></p>
<table>
<thead>
<tr>
<th align="center">指标</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Mean Square Error (MSE, RMSE)</td>
<td align="center">平均方差</td>
</tr>
<tr>
<td align="center">Absolute Error (MAE, RAE)</td>
<td align="center">绝对误差</td>
</tr>
<tr>
<td align="center">R-Squared</td>
<td align="center">R平方值</td>
</tr>
</tbody>
</table>
<h3 id="2162">2.16.2 误差、偏差和方差有什么区别和联系？<a class="headerlink" href="#2162" title="Permanent link">&para;</a></h3>
<p>在机器学习中，Bias(偏差)，Error(误差)，和Variance(方差)存在以下区别和联系：</p>
<p><strong>对于Error </strong>：</p>
<ul>
<li>
<p>误差（error）：一般地，我们把学习器的实际预测输出与样本的真是输出之间的差异称为“误差”。</p>
</li>
<li>
<p>Error = Bias + Variance + Noise，Error反映的是整个模型的准确度。</p>
</li>
</ul>
<p><strong>对于Noise:</strong></p>
<p>噪声：描述了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p>
<p><strong>对于Bias：</strong></p>
<ul>
<li>Bias衡量模型拟合训练数据的能力（训练数据不一定是整个 training dataset，而是只用于训练它的那一部分数据，例如：mini-batch），Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度。</li>
<li>Bias 越小，拟合能力越高（可能产生overfitting）；反之，拟合能力越低（可能产生underfitting）。</li>
<li>偏差越大，越偏离真实数据，如下图第二行所示。</li>
</ul>
<p><strong>对于Variance：</strong></p>
<ul>
<li>
<p>方差公式：<span><span class="MathJax_Preview">S_{N}^{2}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}</span><script type="math/tex">S_{N}^{2}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}</script></span></p>
</li>
<li>
<p>Variance描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散，模型的稳定程度越差。</p>
</li>
<li>Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。</li>
<li>Variance越小，模型的泛化的能力越高；反之，模型的泛化的能力越低。</li>
<li>如果模型在训练集上拟合效果比较优秀，但是在测试集上拟合效果比较差劣，则方差较大，说明模型的稳定程度较差，出现这种现象可能是由于模型对训练集过拟合造成的。 如下图右列所示。</li>
</ul>
<blockquote>
<p><img alt="" src="../img/ch2/2.16.20.1.png" />
</p>
</blockquote>
<h3 id="2163">2.16.3 经验误差与泛化误差<a class="headerlink" href="#2163" title="Permanent link">&para;</a></h3>
<p>经验误差（empirical error）：也叫训练误差（training error），模型在训练集上的误差。 </p>
<p>泛化误差（generalization error）：模型在新样本集（测试集）上的误差称为“泛化误差”。</p>
<h3 id="2164">2.16.4 图解欠拟合、过拟合<a class="headerlink" href="#2164" title="Permanent link">&para;</a></h3>
<p>根据不同的坐标方式，欠拟合与过拟合图解不同。
1. <strong>横轴为训练样本数量，纵轴为误差</strong></p>
<p><img alt="" src="../img/ch2/2.16.4.1.jpg" /></p>
<p>如上图所示，我们可以直观看出欠拟合和过拟合的区别：</p>
<p>​   模型欠拟合：在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大；</p>
<p>​   模型过拟合：在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。</p>
<p>​   模型正常：在训练集以及测试集上，同时具有相对较低的偏差以及方差。</p>
<ol>
<li><strong>横轴为模型复杂程度，纵轴为误差</strong></li>
</ol>
<p><img alt="" src="../img/ch2/2.16.4.2.png" /></p>
<p>​                   红线为测试集上的Error,蓝线为训练集上的Error</p>
<p>​   模型欠拟合：模型在点A处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。</p>
<p>​   模型过拟合：模型在点C处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。 </p>
<p>​   模型正常：模型复杂程度控制在点B处为最优。</p>
<ol>
<li><strong>横轴为正则项系数，纵轴为误差</strong></li>
</ol>
<p><img alt="" src="../img/ch2/2.16.4.3.png" /></p>
<p>​                                             红线为测试集上的Error,蓝线为训练集上的Error</p>
<p>​   模型欠拟合：模型在点C处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。</p>
<p>​   模型过拟合：模型在点A处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。 它通常发生在模型过于复杂的情况下，如参数过多等，会使得模型的预测性能变弱，并且增加数据的波动性。虽然模型在训练时的效果可以表现的很完美，基本上记住了数据的全部特点，但这种模型在未知数据的表现能力会大减折扣，因为简单的模型泛化能力通常都是很弱的。</p>
<p>​   模型正常：模型复杂程度控制在点B处为最优。</p>
<h3 id="2165">2.16.5 如何解决过拟合与欠拟合？<a class="headerlink" href="#2165" title="Permanent link">&para;</a></h3>
<p><strong>如何解决欠拟合：</strong>
1. 添加其他特征项。组合、泛化、相关性、上下文特征、平台特征等特征是特征添加的重要手段，有时候特征项不够会导致模型欠拟合。
2. 添加多项式特征。例如将线性模型添加二次项或三次项使模型泛化能力更强。例如，FM（Factorization Machine）模型、FFM（Field-aware Factorization Machine）模型，其实就是线性模型，增加了二阶多项式，保证了模型一定的拟合程度。
3. 可以增加模型的复杂程度。
4. 减小正则化系数。正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。</p>
<p><strong>如何解决过拟合：</strong>
1. 重新清洗数据，数据不纯会导致过拟合，此类情况需要重新清洗数据。 
2. 增加训练样本数量。 
3. 降低模型复杂程度。 
4. 增大正则项系数。 
5. 采用dropout方法，dropout方法，通俗的讲就是在训练的时候让神经元以一定的概率不工作。 
6. early stopping。 
7. 减少迭代次数。 
8. 增大学习率。 
9. 添加噪声数据。 
10. 树结构中，可以对树进行剪枝。 
11. 减少特征项。</p>
<p>欠拟合和过拟合这些方法，需要根据实际问题，实际模型，进行选择。</p>
<h3 id="2166">2.16.6 交叉验证的主要作用<a class="headerlink" href="#2166" title="Permanent link">&para;</a></h3>
<p>​   为了得到更为稳健可靠的模型，对模型的泛化误差进行评估，得到模型泛化误差的近似值。当有多个模型可以选择时，我们通常选择“泛化误差”最小的模型。 </p>
<p>​   交叉验证的方法有许多种，但是最常用的是：留一交叉验证、k折交叉验证。</p>
<h3 id="2167-k">2.16.7 理解k折交叉验证<a class="headerlink" href="#2167-k" title="Permanent link">&para;</a></h3>
<ol>
<li>将含有N个样本的数据集，分成K份，每份含有N/K个样本。选择其中1份作为测试集，另外K-1份作为训练集，测试集就有K种情况。 </li>
<li>在每种情况中，用训练集训练模型，用测试集测试模型，计算模型的泛化误差。 </li>
<li>交叉验证重复K次，每份验证一次，平均K次的结果或者使用其它结合方式，最终得到一个单一估测，得到模型最终的泛化误差。 </li>
<li>将K种情况下，模型的泛化误差取均值，得到模型最终的泛化误差。  </li>
<li>一般<span><span class="MathJax_Preview">2\leqslant K \leqslant10</span><script type="math/tex">2\leqslant K \leqslant10</script></span>。 k折交叉验证的优势在于，同时重复运用随机产生的子样本进行训练和验证，每次的结果验证一次，10折交叉验证是最常用的。 </li>
<li>训练集中样本数量要足够多，一般至少大于总样本数的50%。 </li>
<li>训练集和测试集必须从完整的数据集中均匀取样。均匀取样的目的是希望减少训练集、测试集与原数据集之间的偏差。当样本数量足够多时，通过随机取样，便可以实现均匀取样的效果。 </li>
</ol>
<h3 id="2168">2.16.8 混淆矩阵<a class="headerlink" href="#2168" title="Permanent link">&para;</a></h3>
<p>第一种混淆矩阵:</p>
<table>
<thead>
<tr>
<th align="center">真实情况T or F</th>
<th align="left">预测为正例1，P</th>
<th align="left">预测为负例0，N</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">本来label标记为1，预测结果真为T、假为F</td>
<td align="left">TP(预测为1，实际为1)</td>
<td align="left">FN(预测为0，实际为1)</td>
</tr>
<tr>
<td align="center">本来label标记为0，预测结果真为T、假为F</td>
<td align="left">FP(预测为1，实际为0)</td>
<td align="left">TN(预测为0，实际也为0)</td>
</tr>
</tbody>
</table>
<p>第二种混淆矩阵:</p>
<table>
<thead>
<tr>
<th align="center">预测情况P or N</th>
<th align="left">实际label为1,预测对了为T</th>
<th align="left">实际label为0,预测对了为T</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">预测为正例1，P</td>
<td align="left">TP(预测为1，实际为1)</td>
<td align="left">FP(预测为1，实际为0)</td>
</tr>
<tr>
<td align="center">预测为负例0，N</td>
<td align="left">FN(预测为0，实际为1)</td>
<td align="left">TN(预测为0，实际也为0)</td>
</tr>
</tbody>
</table>
<h3 id="2169">2.16.9 错误率及精度<a class="headerlink" href="#2169" title="Permanent link">&para;</a></h3>
<ol>
<li>错误率（Error Rate）：分类错误的样本数占样本总数的比例。</li>
<li>精度（accuracy）：分类正确的样本数占样本总数的比例。</li>
</ol>
<h3 id="21610">2.16.10 查准率与查全率<a class="headerlink" href="#21610" title="Permanent link">&para;</a></h3>
<p>将算法预测的结果分成四种情况： 
1. 正确肯定（True Positive,TP）：预测为真，实际为真 
2. 正确否定（True Negative,TN）：预测为假，实际为假 
3. 错误肯定（False Positive,FP）：预测为真，实际为假 
4. 错误否定（False Negative,FN）：预测为假，实际为真</p>
<p>则： </p>
<p>查准率（Precision）=TP/（TP+FP）</p>
<p><strong>理解</strong>：预测出为阳性的样本中，正确的有多少。区别准确率（正确预测出的样本，包括正确预测为阳性、阴性，占总样本比例）。
例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。 </p>
<p>查全率（Recall）=TP/（TP+FN）</p>
<p><strong>理解</strong>：正确预测为阳性的数量占总样本中阳性数量的比例。
例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。 </p>
<h3 id="21611-rocauc">2.16.11 ROC与AUC<a class="headerlink" href="#21611-rocauc" title="Permanent link">&para;</a></h3>
<p>​   ROC全称是“受试者工作特征”（Receiver Operating Characteristic）。</p>
<p>​   ROC曲线的面积就是AUC（Area Under Curve）。</p>
<p>​   AUC用于衡量“二分类问题”机器学习算法性能（泛化能力）。</p>
<p>​   ROC曲线，通过将连续变量设定出多个不同的临界值，从而计算出一系列真正率和假正率，再以假正率为横坐标、真正率为纵坐标绘制成曲线，曲线下面积越大，推断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为假正率和真正率均较高的临界值。 </p>
<p>​   对于分类器，或者说分类算法，评价指标主要有Precision，Recall，F-score。下图是一个ROC曲线的示例。</p>
<p><img alt="" src="../img/ch2/2.40.10/1.png" /></p>
<p>ROC曲线的横坐标为False Positive Rate（FPR），纵坐标为True Positive Rate（TPR）。其中
$$
TPR = \frac{TP}{TP+FN} ,FPR = \frac{FP}{FP+TN}
$$</p>
<p>​   下面着重介绍ROC曲线图中的四个点和一条线。
​   第一个点(0,1)，即FPR=0, TPR=1，这意味着FN（False Negative）=0，并且FP（False Positive）=0。意味着这是一个完美的分类器，它将所有的样本都正确分类。
​   第二个点(1,0)，即FPR=1，TPR=0，意味着这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。
​   第三个点(0,0)，即FPR=TPR=0，即FP（False Positive）=TP（True Positive）=0，可以发现该分类器预测所有的样本都为负样本（Negative）。
​   第四个点(1,1)，即FPR=TPR=1，分类器实际上预测所有的样本都为正样本。
​   经过以上分析，ROC曲线越接近左上角，该分类器的性能越好。</p>
<p>​   ROC曲线所覆盖的面积称为AUC（Area Under Curve），可以更直观的判断学习器的性能，AUC越大则性能越好。  </p>
<h3 id="21612-roc">2.16.12 如何画ROC曲线？<a class="headerlink" href="#21612-roc" title="Permanent link">&para;</a></h3>
<p>​   下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</p>
<p>步骤：
    1、假设已经得出一系列样本被划分为正类的概率，按照大小排序。
    2、从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。
    3、每次选取一个不同的threshold，得到一组FPR和TPR，即ROC曲线上的一点。以此共得到20组FPR和TPR的值。
    4、根据3、中的每个坐标点，画图。</p>
<p><img alt="" src="../img/ch2/2.40.11/1.jpg" /></p>
<h3 id="21613-tprfpr">2.16.13 如何计算TPR，FPR？<a class="headerlink" href="#21613-tprfpr" title="Permanent link">&para;</a></h3>
<p>1、分析数据
y_true = [0, 0, 1, 1]；scores = [0.1, 0.4, 0.35, 0.8]；
2、列表</p>
<table>
<thead>
<tr>
<th>样本</th>
<th>预测属于P的概率(score)</th>
<th>真实类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>y[0]</td>
<td>0.1</td>
<td>N</td>
</tr>
<tr>
<td>y[1]</td>
<td>0.4</td>
<td>N</td>
</tr>
<tr>
<td>y[2]</td>
<td>0.35</td>
<td>P</td>
</tr>
<tr>
<td>y[3]</td>
<td>0.8</td>
<td>P</td>
</tr>
</tbody>
</table>
<p>3、将截断点依次取为score值，计算TPR和FPR。
当截断点为0.1时：
说明只要score&gt;=0.1，它的预测类别就是正例。 因为4个样本的score都大于等于0.1，所以，所有样本的预测类别都为P。
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [1, 1, 1, 1]；
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=2</td>
<td>FN=0</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=2</td>
<td>TN=0</td>
</tr>
</tbody>
</table>
<p>由此可得：
TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 1；</p>
<p>当截断点为0.35时：
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 1, 1];
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=2</td>
<td>FN=0</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=1</td>
<td>TN=1</td>
</tr>
</tbody>
</table>
<p>由此可得：
TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 0.5；</p>
<p>当截断点为0.4时：
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 0, 1]；
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=1</td>
<td>FN=1</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=1</td>
<td>TN=1</td>
</tr>
</tbody>
</table>
<p>由此可得：
TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0.5；</p>
<p>当截断点为0.8时：
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 0, 0, 1]；</p>
<p>正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=1</td>
<td>FN=1</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=0</td>
<td>TN=2</td>
</tr>
</tbody>
</table>
<p>由此可得：
TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0；</p>
<p>4、根据TPR、FPR值，以FPR为横轴，TPR为纵轴画图。</p>
<h3 id="21614-auc">2.16.14 如何计算AUC？<a class="headerlink" href="#21614-auc" title="Permanent link">&para;</a></h3>
<ul>
<li>将坐标点按照横坐标FPR排序 。</li>
<li>计算第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>个坐标点和第<span><span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script></span>个坐标点的间距<span><span class="MathJax_Preview">dx</span><script type="math/tex">dx</script></span> 。 </li>
<li>获取第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>或者<span><span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script></span>个坐标点的纵坐标y。</li>
<li>计算面积微元<span><span class="MathJax_Preview">ds=ydx</span><script type="math/tex">ds=ydx</script></span>。</li>
<li>对面积微元进行累加，得到AUC。</li>
</ul>
<h3 id="21615-rocauc">2.16.15 为什么使用Roc和Auc评价分类器？<a class="headerlink" href="#21615-rocauc" title="Permanent link">&para;</a></h3>
<p>​   模型有很多评估方法，为什么还要使用ROC和AUC呢？
​   因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变换的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现样本类不平衡，即正负样本比例差距较大，而且测试数据中的正负样本也可能随着时间变化。</p>
<h3 id="21616-auc">2.16.16 直观理解AUC<a class="headerlink" href="#21616-auc" title="Permanent link">&para;</a></h3>
<p>​   下图展现了三种AUC的值： </p>
<p><img alt="" src="../img/ch2/2.40.15/1.png" /></p>
<p>​   AUC是衡量二分类模型优劣的一种评价指标，表示正例排在负例前面的概率。其他评价指标有精确度、准确率、召回率，而AUC比这三者更为常用。
​   一般在分类模型中，预测结果都是以概率的形式表现，如果要计算准确率，通常都会手动设置一个阈值来将对应的概率转化成类别，这个阈值也就很大程度上影响了模型准确率的计算。
​   举例：
​   现在假设有一个训练好的二分类器对10个正负样本（正例5个，负例5个）预测，得分按高到低排序得到的最好预测结果为[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]，即5个正例均排在5个负例前面，正例排在负例前面的概率为100%。然后绘制其ROC曲线，由于是10个样本，除去原点我们需要描10个点，如下：</p>
<p><img alt="" src="../img/ch2/2.16.17-1.png" /></p>
<p>​   描点方式按照样本预测结果的得分高低从左至右开始遍历。从原点开始，每遇到1便向y轴正方向移动y轴最小步长1个单位，这里是&#8533;=0.2；每遇到0则向x轴正方向移动x轴最小步长1个单位，这里也是0.2。不难看出，上图的AUC等于1，印证了正例排在负例前面的概率的确为100%。</p>
<p>​   假设预测结果序列为[1, 1, 1, 1, 0, 1, 0, 0, 0, 0]。</p>
<p><img alt="" src="../img/ch2/2.16.17-2.png" /></p>
<p>​   计算上图的AUC为0.96与计算正例与排在负例前面的概率0.8 × 1 + 0.2 × 0.8 = 0.96相等，而左上角阴影部分的面积则是负例排在正例前面的概率0.2 × 0.2 = 0.04。</p>
<p>​   假设预测结果序列为[1, 1, 1, 0, 1, 0, 1, 0, 0, 0]。</p>
<p><img alt="" src="../img/ch2/2.16.17-3.png" /></p>
<p>​   计算上图的AUC为0.88与计算正例与排在负例前面的概率0.6 × 1 + 0.2 × 0.8 + 0.2 × 0.6 = 0.88相等，左上角阴影部分的面积是负例排在正例前面的概率0.2 × 0.2 × 3 = 0.12。</p>
<h3 id="21617">2.16.17 代价敏感错误率与代价曲线<a class="headerlink" href="#21617" title="Permanent link">&para;</a></h3>
<p>不同的错误会产生不同代价。以二分法为例，设置代价矩阵如下：</p>
<p><img alt="" src="../img/ch2/2-1.png" /></p>
<p>当判断正确的时候，值为0，不正确的时候，分别为<span><span class="MathJax_Preview">Cost_{01}​</span><script type="math/tex">Cost_{01}​</script></span>和<span><span class="MathJax_Preview">Cost_{10}​</span><script type="math/tex">Cost_{10}​</script></span> 。</p>
<p><span><span class="MathJax_Preview">Cost_{10}</span><script type="math/tex">Cost_{10}</script></span>:表示实际为反例但预测成正例的代价。</p>
<p><span><span class="MathJax_Preview">Cost_{01}</span><script type="math/tex">Cost_{01}</script></span>:表示实际为正例但是预测为反例的代价。</p>
<p><strong>代价敏感错误率</strong>=样本中由模型得到的错误值与代价乘积之和 / 总样本。
其数学表达式为：
$$
E(f;D;cost)=\frac{1}{m}\left( \sum_{x_{i} \in D^{+}}({f(x_i)\neq y_i})\times Cost_{01}+ \sum_{x_{i} \in D^{-}}({f(x_i)\neq y_i})\times Cost_{10}\right)
$$
<span><span class="MathJax_Preview">D^{+}、D^{-}​</span><script type="math/tex">D^{+}、D^{-}​</script></span>分别代表样例集的正例子集和反例子集，x是预测值，y是真实值。</p>
<p><strong>代价曲线</strong>：
    在均等代价时，ROC曲线不能直接反应出模型的期望总体代价，而代价曲线可以。
代价曲线横轴为[0,1]的正例函数代价：
$$
P(+)Cost=\frac{p<em>Cost_{01}}{p</em>Cost_{01}+(1-p)*Cost_{10}}
$$
其中p是样本为正例的概率。</p>
<p>代价曲线纵轴维[0,1]的归一化代价：
$$
Cost_{norm}=\frac{FNR<em>p</em>Cost_{01}+FNR<em>(1-p)</em>Cost_{10}}{p<em>Cost_{01}+(1-p)</em>Cost_{10}}
$$</p>
<p>其中FPR为假阳率，FNR=1-TPR为假阴率。</p>
<p>注：ROC每个点，对应代价平面上一条线。</p>
<p>例如，ROC上(TPR,FPR),计算出FNR=1-TPR，在代价平面上绘制一条从(0,FPR)到(1,FNR)的线段，面积则为该条件下期望的总体代价。所有线段下界面积，所有条件下学习器的期望总体代价。</p>
<p><img alt="" src="../img/ch2/2.16.18.1.png" /></p>
<h3 id="21618">2.16.18 模型有哪些比较检验方法<a class="headerlink" href="#21618" title="Permanent link">&para;</a></h3>
<p>正确性分析：模型稳定性分析，稳健性分析，收敛性分析，变化趋势分析，极值分析等。
有效性分析：误差分析，参数敏感性分析，模型对比检验等。
有用性分析：关键数据求解，极值点，拐点，变化趋势分析，用数据验证动态模拟等。
高效性分析：时空复杂度分析与现有进行比较等。</p>
<h3 id="21619">2.16.19 为什么使用标准差？<a class="headerlink" href="#21619" title="Permanent link">&para;</a></h3>
<p>方差公式为：<span><span class="MathJax_Preview">S^2_{N}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}​</span><script type="math/tex">S^2_{N}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}​</script></span></p>
<p>标准差公式为：<span><span class="MathJax_Preview">S_{N}=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​</span><script type="math/tex">S_{N}=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​</script></span></p>
<p>样本标准差公式为：<span><span class="MathJax_Preview">S_{N}=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​</span><script type="math/tex">S_{N}=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​</script></span></p>
<p>与方差相比，使用标准差来表示数据点的离散程度有3个好处：
1、表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知。</p>
<p>2、表示离散程度的数字单位与样本数据的单位一致，更方便做后续的分析运算。</p>
<p>3、在样本数据大致符合正态分布的情况下，标准差具有方便估算的特性：68%的数据点落在平均值前后1个标准差的范围内、95%的数据点落在平均值前后2个标准差的范围内，而99%的数据点将会落在平均值前后3个标准差的范围内。</p>
<h3 id="21620">2.16.20 类别不平衡产生原因？<a class="headerlink" href="#21620" title="Permanent link">&para;</a></h3>
<p>​   类别不平衡（class-imbalance）是指分类任务中不同类别的训练样例数目差别很大的情况。 </p>
<p>产生原因：</p>
<p>​   分类学习算法通常都会假设不同类别的训练样例数目基本相同。如果不同类别的训练样例数目差别很大，则会影响学习结果，测试结果变差。例如二分类问题中有998个反例，正例有2个，那学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到99.8%的精度；然而这样的分类器没有价值。</p>
<h3 id="21621">2.16.21 常见的类别不平衡问题解决方法<a class="headerlink" href="#21621" title="Permanent link">&para;</a></h3>
<p>防止类别不平衡对学习造成的影响，在构建分类模型之前，需要对分类不平衡性问题进行处理。主要解决方法有：</p>
<p>1、扩大数据集</p>
<p>​   增加包含小类样本数据的数据，更多的数据能得到更多的分布信息。</p>
<p>2、对大类数据欠采样</p>
<p>​   减少大类数据样本个数，使与小样本个数接近。
​   缺点：欠采样操作时若随机丢弃大类样本，可能会丢失重要信息。 
​   代表算法：EasyEnsemble。其思想是利用集成学习机制，将大类划分为若干个集合供不同的学习器使用。相当于对每个学习器都进行欠采样，但对于全局则不会丢失重要信息。</p>
<p>3、对小类数据过采样</p>
<p>​   过采样：对小类的数据样本进行采样来增加小类的数据样本个数。 </p>
<p>​   代表算法：SMOTE和ADASYN。 </p>
<p>​   SMOTE：通过对训练集中的小类数据进行插值来产生额外的小类样本数据。</p>
<p>​   新的少数类样本产生的策略：对每个少数类样本a，在a的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。  <br />
​   ADASYN：根据学习难度的不同，对不同的少数类别的样本使用加权分布，对于难以学习的少数类的样本，产生更多的综合数据。 通过减少类不平衡引入的偏差和将分类决策边界自适应地转移到困难的样本两种手段，改善了数据分布。</p>
<p>4、使用新评价指标</p>
<p>​   如果当前评价指标不适用，则应寻找其他具有说服力的评价指标。比如准确度这个评价指标在类别不均衡的分类任务中并不适用，甚至进行误导。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。</p>
<p>5、选择新算法</p>
<p>​   不同的算法适用于不同的任务与数据，应该使用不同的算法进行比较。</p>
<p>6、数据代价加权</p>
<p>​   例如当分类任务是识别小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值，从而使得分类器将重点集中在小类样本身上。</p>
<p>7、转化问题思考角度</p>
<p>​   例如在分类问题时，把小类的样本作为异常点，将问题转化为异常点检测或变化趋势检测问题。 异常点检测即是对那些罕见事件进行识别。变化趋势检测区别于异常点检测在于其通过检测不寻常的变化趋势来识别。 </p>
<p>8、将问题细化分析</p>
<p>​   对问题进行分析与挖掘，将问题划分成多个更小的问题，看这些小问题是否更容易解决。 </p>
<h2 id="217">2.17 决策树<a class="headerlink" href="#217" title="Permanent link">&para;</a></h2>
<h3 id="2171">2.17.1 决策树的基本原理<a class="headerlink" href="#2171" title="Permanent link">&para;</a></h3>
<p>​   决策树（Decision Tree）是一种分而治之的决策过程。一个困难的预测问题，通过树的分支节点，被划分成两个或多个较为简单的子集，从结构上划分为不同的子问题。将依规则分割数据集的过程不断递归下去（Recursive Partitioning）。随着树的深度不断增加，分支节点的子集越来越小，所需要提的问题数也逐渐简化。当分支节点的深度或者问题的简单程度满足一定的停止规则（Stopping Rule）时, 该分支节点会停止分裂，此为自上而下的停止阈值（Cutoff Threshold）法；有些决策树也使用自下而上的剪枝（Pruning）法。</p>
<h3 id="2172">2.17.2 决策树的三要素？<a class="headerlink" href="#2172" title="Permanent link">&para;</a></h3>
<p>​   一棵决策树的生成过程主要分为以下3个部分：  </p>
<p>​   1、特征选择：从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准，从而衍生出不同的决策树算法。 </p>
<p>​   2、决策树生成：根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则决策树停止生长。树结构来说，递归结构是最容易理解的方式。 </p>
<p>​   3、剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。</p>
<h3 id="2173">2.17.3 决策树学习基本算法<a class="headerlink" href="#2173" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../img/ch2/2-5.png" /></p>
<h3 id="2174">2.17.4 决策树算法优缺点<a class="headerlink" href="#2174" title="Permanent link">&para;</a></h3>
<p><strong>决策树算法的优点</strong>：  </p>
<p>1、决策树算法易理解，机理解释起来简单。 </p>
<p>2、决策树算法可以用于小数据集。</p>
<p>3、决策树算法的时间复杂度较小，为用于训练决策树的数据点的对数。</p>
<p>4、相比于其他算法智能分析一种类型变量，决策树算法可处理数字和数据的类别。</p>
<p>5、能够处理多输出的问题。 </p>
<p>6、对缺失值不敏感。</p>
<p>7、可以处理不相关特征数据。</p>
<p>8、效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</p>
<p><strong>决策树算法的缺点</strong>： </p>
<p>1、对连续性的字段比较难预测。</p>
<p>2、容易出现过拟合。</p>
<p>3、当类别太多时，错误可能就会增加的比较快。</p>
<p>4、在处理特征关联性比较强的数据时表现得不是太好。</p>
<p>5、对于各类别样本数量不一致的数据，在决策树当中，信息增益的结果偏向于那些具有更多数值的特征。</p>
<h3 id="2175">2.17.5 熵的概念以及理解<a class="headerlink" href="#2175" title="Permanent link">&para;</a></h3>
<p>​   熵：度量随机变量的不确定性。<br />
​   定义：假设随机变量X的可能取值有<span><span class="MathJax_Preview">x_{1},x_{2},...,x_{n}</span><script type="math/tex">x_{1},x_{2},...,x_{n}</script></span>，对于每一个可能的取值<span><span class="MathJax_Preview">x_{i}</span><script type="math/tex">x_{i}</script></span>，其概率为<span><span class="MathJax_Preview">P(X=x_{i})=p_{i},i=1,2...,n</span><script type="math/tex">P(X=x_{i})=p_{i},i=1,2...,n</script></span>。随机变量的熵为：
$$
H(X)=-\sum_{i=1}^{n}p_{i}log_{2}p_{i}
$$
​       对于样本集合，假设样本有k个类别，每个类别的概率为<span><span class="MathJax_Preview">\frac{|C_{k}|}{|D|}</span><script type="math/tex">\frac{|C_{k}|}{|D|}</script></span>，其中 <span><span class="MathJax_Preview">{|C_{k}|}{|D|}</span><script type="math/tex">{|C_{k}|}{|D|}</script></span>为类别为k的样本个数，<span><span class="MathJax_Preview">|D|​</span><script type="math/tex">|D|​</script></span>为样本总数。样本集合D的熵为：
$$
H(D)=-\sum_{k=1}^{k}\frac{|C_{k}|}{|D|}log_{2}\frac{|C_{k}|}{|D|}
$$</p>
<h3 id="2176">2.17.6 信息增益的理解<a class="headerlink" href="#2176" title="Permanent link">&para;</a></h3>
<p>​   定义：以某特征划分数据集前后的熵的差值。 
​   熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。  ​   假设划分前样本集合D的熵为H(D)。使用某个特征A划分数据集D，计算划分后的数据子集的熵为H(D|A)。<br />
​   则信息增益为：
$$
g(D,A)=H(D)-H(D|A)
$$
​   <em>注：</em>在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。<br />
​   思想：计算所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。<br />
​   另外这里提一下信息增益比相关知识：
​   <span><span class="MathJax_Preview">信息增益比=惩罚参数\times信息增益</span><script type="math/tex">信息增益比=惩罚参数\times信息增益</script></span><br />
​   信息增益比本质：在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。<br />
​   惩罚参数：数据集D以特征A作为随机变量的熵的倒数。</p>
<h3 id="2177">2.17.7 剪枝处理的作用及策略？<a class="headerlink" href="#2177" title="Permanent link">&para;</a></h3>
<p>​   剪枝处理是决策树学习算法用来解决过拟合问题的一种办法。</p>
<p>​   在决策树算法中，为了尽可能正确分类训练样本， 节点划分过程不断重复， 有时候会造成决策树分支过多，以至于将训练样本集自身特点当作泛化特点， 而导致过拟合。 因此可以采用剪枝处理来去掉一些分支来降低过拟合的风险。 </p>
<p>​   剪枝的基本策略有预剪枝（pre-pruning）和后剪枝（post-pruning）。</p>
<p>​   预剪枝：在决策树生成过程中，在每个节点划分前先估计其划分后的泛化性能， 如果不能提升，则停止划分，将当前节点标记为叶结点。 </p>
<p>​   后剪枝：生成决策树以后，再自下而上对非叶结点进行考察， 若将此节点标记为叶结点可以带来泛化性能提升，则修改之。</p>
<h2 id="218">2.18 支持向量机<a class="headerlink" href="#218" title="Permanent link">&para;</a></h2>
<h3 id="2181">2.18.1 什么是支持向量机<a class="headerlink" href="#2181" title="Permanent link">&para;</a></h3>
<p>​   支持向量：在求解的过程中，会发现只根据部分数据就可以确定分类器，这些数据称为支持向量。</p>
<p>​   支持向量机（Support Vector Machine，SVM）：其含义是通过支持向量运算的分类器。</p>
<p>​   在一个二维环境中，其中点R，S，G点和其它靠近中间黑线的点可以看作为支持向量，它们可以决定分类器，即黑线的具体参数。</p>
<p><img alt="" src="../img/ch2/2-6.png" /></p>
<p>​   支持向量机是一种二分类模型，它的目的是寻找一个超平面来对样本进行分割，分割的原则是边界最大化，最终转化为一个凸二次规划问题来求解。由简至繁的模型包括：</p>
<p>​   当训练样本线性可分时，通过硬边界（hard margin）最大化，学习一个线性可分支持向量机；</p>
<p>​   当训练样本近似线性可分时，通过软边界（soft margin）最大化，学习一个线性支持向量机；</p>
<p>​   当训练样本线性不可分时，通过核技巧和软边界最大化，学习一个非线性支持向量机；</p>
<h3 id="2182">2.18.2 支持向量机能解决哪些问题？<a class="headerlink" href="#2182" title="Permanent link">&para;</a></h3>
<p><strong>线性分类</strong></p>
<p>​   在训练数据中，每个数据都有n个的属性和一个二分类类别标志，我们可以认为这些数据在一个n维空间里。我们的目标是找到一个n-1维的超平面，这个超平面可以将数据分成两部分，每部分数据都属于同一个类别。</p>
<p>​   这样的超平面有很多，假如我们要找到一个最佳的超平面。此时，增加一个约束条件：要求这个超平面到每边最近数据点的距离是最大的，成为最大边距超平面。这个分类器即为最大边距分类器。</p>
<p><strong>非线性分类</strong></p>
<p>​   SVM的一个优势是支持非线性分类。它结合使用拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件，以及核函数可以生成非线性分类器。</p>
<h3 id="2183">2.18.3 核函数特点及其作用？<a class="headerlink" href="#2183" title="Permanent link">&para;</a></h3>
<p>​   引入核函数目的：把原坐标系里线性不可分的数据用核函数Kernel投影到另一个空间，尽量使得数据在新的空间里线性可分。<br />
​   核函数方法的广泛应用，与其特点是分不开的：  </p>
<p>1）核函数的引入避免了“维数灾难”，大大减小了计算量。而输入空间的维数n对核函数矩阵无影响。因此，核函数方法可以有效处理高维输入。</p>
<p>2）无需知道非线性变换函数Φ的形式和参数。</p>
<p>3）核函数的形式和参数的变化会隐式地改变从输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种核函数方法的性能。</p>
<p>4）核函数方法可以和不同的算法相结合，形成多种不同的基于核函数技术的方法，且这两部分的设计可以单独进行，并可以为不同的应用选择不同的核函数和算法。</p>
<h3 id="2184-svm">2.18.4 SVM为什么引入对偶问题？<a class="headerlink" href="#2184-svm" title="Permanent link">&para;</a></h3>
<p>1，对偶问题将原始问题中的约束转为了对偶问题中的等式约束，对偶问题往往更加容易求解。</p>
<p>2，可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）。</p>
<p>3，在优化理论中，目标函数 f(x) 会有多种形式：如果目标函数和约束条件都为变量 x 的线性函数，称该问题为线性规划；如果目标函数为二次函数，约束条件为线性函数，称该最优化问题为二次规划；如果目标函数或者约束条件均为非线性函数，称该最优化问题为非线性规划。每个线性规划问题都有一个与之对应的对偶问题，对偶问题有非常良好的性质，以下列举几个：</p>
<p>​   a, 对偶问题的对偶是原问题；</p>
<p>​   b, 无论原始问题是否是凸的，对偶问题都是凸优化问题；</p>
<p>​   c, 对偶问题可以给出原始问题一个下界；</p>
<p>​   d, 当满足一定条件时，原始问题与对偶问题的解是完全等价的。</p>
<h3 id="2185-svm">2.18.5 如何理解SVM中的对偶问题<a class="headerlink" href="#2185-svm" title="Permanent link">&para;</a></h3>
<p>在硬边界支持向量机中，问题的求解可以转化为凸二次规划问题。</p>
<p>​   假设优化目标为
$$
\begin{align}
&amp;\min_{\boldsymbol w, b}\frac{1}{2}||\boldsymbol w||^2\
&amp;s.t. y_i(\boldsymbol w^T\boldsymbol x_i+b)\geqslant 1, i=1,2,\cdots,m.\
\end{align}  \tag{1}
$$
<strong>step 1</strong>. 转化问题：
$$
\min_{\boldsymbol w, b} \max_{\alpha_i \geqslant 0}  \left{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right}  \tag{2}
$$
上式等价于原问题，因为若满足(1)中不等式约束，则(2)式求max时,<span><span class="MathJax_Preview">\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))</span><script type="math/tex">\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))</script></span>必须取0，与(1)等价；若不满足(1)中不等式约束，(2)中求max会得到无穷大。 交换min和max获得其对偶问题:
$$
\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b}  \left{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right}
$$
交换之后的对偶问题和原问题并不相等，上式的解小于等于原问题的解。</p>
<p><strong>step 2</strong>.现在的问题是如何找到问题(1) 的最优值的一个最好的下界? 
$$
\frac{1}{2}||\boldsymbol w||^2 &lt; v\
1 - y_i(\boldsymbol w^T\boldsymbol x_i+b) \leqslant 0\tag{3}
$$
若方程组(3)无解， 则v是问题(1)的一个下界。若(3)有解， 则 
$$
\forall \boldsymbol \alpha &gt;  0 ,  \min_{\boldsymbol w, b}  \left{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right} &lt; v
$$
由逆否命题得：若 
$$
\exists \boldsymbol \alpha &gt;  0 ,  \min_{\boldsymbol w, b}  \left{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right} \geqslant v
$$
则(3)无解。</p>
<p>那么v是问题</p>
<p>(1)的一个下界。 
 要求得一个好的下界，取最大值即可 
$$
\max_{\alpha_i \geqslant 0}  \min_{\boldsymbol w, b} \left{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right}
$$
<strong>step 3</strong>. 令
$$
L(\boldsymbol w, b,\boldsymbol a) =   \frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))
$$
<span><span class="MathJax_Preview">p^*</span><script type="math/tex">p^*</script></span>为原问题的最小值，对应的<span><span class="MathJax_Preview">w,b</span><script type="math/tex">w,b</script></span>分别为<span><span class="MathJax_Preview">w^*,b^*</span><script type="math/tex">w^*,b^*</script></span>,则对于任意的<span><span class="MathJax_Preview">a&gt;0</span><script type="math/tex">a>0</script></span>:
$$
p^<em> = \frac{1}{2}||\boldsymbol w<sup>*||</sup>2 \geqslant  L(\boldsymbol w^</em>, b,\boldsymbol a) \geqslant \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)
$$
则 <span><span class="MathJax_Preview">\min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)</span><script type="math/tex">\min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)</script></span>是问题（1）的一个下界。</p>
<p>此时，取最大值即可求得好的下界，即
$$
\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)
$$</p>
<h3 id="2187">2.18.7 常见的核函数有哪些？<a class="headerlink" href="#2187" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>核函数</th>
<th>表达式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear Kernel线性核</td>
<td><span><span class="MathJax_Preview">k(x,y)=x^{t}y+c</span><script type="math/tex">k(x,y)=x^{t}y+c</script></span></td>
<td></td>
</tr>
<tr>
<td>Polynomial Kernel多项式核</td>
<td><span><span class="MathJax_Preview">k(x,y)=(ax^{t}y+c)^{d}</span><script type="math/tex">k(x,y)=(ax^{t}y+c)^{d}</script></span></td>
<td><span><span class="MathJax_Preview">d\geqslant1</span><script type="math/tex">d\geqslant1</script></span>为多项式的次数</td>
</tr>
<tr>
<td>Exponential Kernel指数核</td>
<td><span><span class="MathJax_Preview">k(x,y)=exp(-\frac{\left \|x-y \right \|}{2\sigma ^{2}})</span><script type="math/tex">k(x,y)=exp(-\frac{\left \|x-y \right \|}{2\sigma ^{2}})</script></span></td>
<td><span><span class="MathJax_Preview">\sigma&gt;0</span><script type="math/tex">\sigma>0</script></span></td>
</tr>
<tr>
<td>Gaussian Kernel高斯核</td>
<td><span><span class="MathJax_Preview">k(x,y)=exp(-\frac{\left \|x-y \right \|^{2}}{2\sigma ^{2}})</span><script type="math/tex">k(x,y)=exp(-\frac{\left \|x-y \right \|^{2}}{2\sigma ^{2}})</script></span></td>
<td><span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>为高斯核的带宽，<span><span class="MathJax_Preview">\sigma&gt;0</span><script type="math/tex">\sigma>0</script></span>,</td>
</tr>
<tr>
<td>Laplacian Kernel拉普拉斯核</td>
<td><span><span class="MathJax_Preview">k(x,y)=exp(-\frac{\left \|x-y \right \|}{\sigma})</span><script type="math/tex">k(x,y)=exp(-\frac{\left \|x-y \right \|}{\sigma})</script></span></td>
<td><span><span class="MathJax_Preview">\sigma&gt;0</span><script type="math/tex">\sigma>0</script></span></td>
</tr>
<tr>
<td>ANOVA Kernel</td>
<td><span><span class="MathJax_Preview">k(x,y)=exp(-\sigma(x^{k}-y^{k})^{2})^{d}</span><script type="math/tex">k(x,y)=exp(-\sigma(x^{k}-y^{k})^{2})^{d}</script></span></td>
<td></td>
</tr>
<tr>
<td>Sigmoid Kernel</td>
<td><span><span class="MathJax_Preview">k(x,y)=tanh(ax^{t}y+c)</span><script type="math/tex">k(x,y)=tanh(ax^{t}y+c)</script></span></td>
<td><span><span class="MathJax_Preview">tanh</span><script type="math/tex">tanh</script></span>为双曲正切函数，<span><span class="MathJax_Preview">a&gt;0,c&lt;0</span><script type="math/tex">a>0,c<0</script></span></td>
</tr>
</tbody>
</table>
<h3 id="2189-svm">2.18.9 SVM主要特点？<a class="headerlink" href="#2189-svm" title="Permanent link">&para;</a></h3>
<p>特点：</p>
<p>(1)  SVM方法的理论基础是非线性映射，SVM利用内积核函数代替向高维空间的非线性映射。<br />
(2)  SVM的目标是对特征空间划分得到最优超平面，SVM方法核心是最大化分类边界。<br />
(3)  支持向量是SVM的训练结果，在SVM分类决策中起决定作用的是支持向量。<br />
(4)  SVM是一种有坚实理论基础的新颖的适用小样本学习方法。它基本上不涉及概率测度及大数定律等，也简化了通常的分类和回归等问题。
(5)  SVM的最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。<br />
(6)  少数支持向量决定了最终结果，这不但可以帮助我们抓住关键样本、“剔除”大量冗余样本,而且注定了该方法不但算法简单，而且具有较好的“鲁棒性”。这种鲁棒性主要体现在：
​        ①增、删非支持向量样本对模型没有影响;<br />
​        ②支持向量样本集具有一定的鲁棒性;<br />
​        ③有些成功的应用中，SVM方法对核的选取不敏感<br />
(7)  SVM学习问题可以表示为凸优化问题，因此可以利用已知的有效算法发现目标函数的全局最小值。而其他分类方法（如基于规则的分类器和人工神经网络）都采用一种基于贪心学习的策略来搜索假设空间，这种方法一般只能获得局部最优解。<br />
(8)  SVM通过最大化决策边界的边缘来控制模型的能力。尽管如此，用户必须提供其他参数，如使用核函数类型和引入松弛变量等。 
(9)  SVM在小样本训练集上能够得到比其它算法好很多的结果。SVM优化目标是结构化风险最小，而不是经验风险最小，避免了过拟合问题，通过margin的概念，得到对数据分布的结构化描述，减低了对数据规模和数据分布的要求，有优秀的泛化能力。<br />
(10)  它是一个凸优化问题，因此局部最优解一定是全局最优解的优点。  </p>
<h3 id="21810-svm">2.18.10 SVM主要缺点？<a class="headerlink" href="#21810-svm" title="Permanent link">&para;</a></h3>
<p>(1) SVM算法对大规模训练样本难以实施<br />
​        SVM的空间消耗主要是存储训练样本和核矩阵，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。<br />
​        如果数据量很大，SVM的训练时间就会比较长，如垃圾邮件的分类检测，没有使用SVM分类器，而是使用简单的朴素贝叶斯分类器，或者是使用逻辑回归模型分类。</p>
<p>(2) 用SVM解决多分类问题存在困难</p>
<p>​        经典的支持向量机算法只给出了二类分类的算法，而在实际应用中，一般要解决多类的分类问题。可以通过多个二类支持向量机的组合来解决。主要有一对多组合模式、一对一组合模式和SVM决策树；再就是通过构造多个分类器的组合来解决。主要原理是克服SVM固有的缺点，结合其他算法的优势，解决多类问题的分类精度。如：与粗糙集理论结合，形成一种优势互补的多类问题的组合分类器。</p>
<p>(3) 对缺失数据敏感，对参数和核函数的选择敏感</p>
<p>​        支持向量机性能的优劣主要取决于核函数的选取，所以对于一个实际问题而言，如何根据实际的数据模型选择合适的核函数从而构造SVM算法。目前比较成熟的核函数及其参数的选择都是人为的，根据经验来选取的，带有一定的随意性。在不同的问题领域，核函数应当具有不同的形式和参数，所以在选取时候应该将领域知识引入进来，但是目前还没有好的方法来解决核函数的选取问题。</p>
<h3 id="21811-svm">2.18.11 逻辑回归与SVM的异同<a class="headerlink" href="#21811-svm" title="Permanent link">&para;</a></h3>
<p>相同点：</p>
<ul>
<li>LR和SVM都是<strong>分类</strong>算法。</li>
<li>LR和SVM都是<strong>监督学习</strong>算法。</li>
<li>LR和SVM都是<strong>判别模型</strong>。</li>
<li>如果不考虑核函数，LR和SVM都是<strong>线性分类</strong>算法，也就是说他们的分类决策面都是线性的。
   说明：LR也是可以用核函数的.但LR通常不采用核函数的方法。（<strong>计算量太大</strong>）</li>
</ul>
<p>不同点：</p>
<p><strong>1、LR采用log损失，SVM采用合页(hinge)损失。</strong>
逻辑回归的损失函数：
$$
J(\theta)=-\frac{1}{m}\sum<sup>m_{i=1}\left[y</sup>{i}logh_{\theta}(x^{i})+ (1-y<sup>{i})log(1-h_{\theta}(x</sup>{i}))\right]
$$
支持向量机的目标函数:
$$
L(w,n,a)=\frac{1}{2}||w||<sup>2-\sum</sup>n_{i=1}\alpha_i \left( y_i(w^Tx_i+b)-1\right)
$$
​   逻辑回归方法基于概率理论，假设样本为1的概率可以用sigmoid函数来表示，然后通过<strong>极大似然估计</strong>的方法估计出参数的值。<br />
​   支持向量机基于几何<strong>边界最大化</strong>原理，认为存在最大几何边界的分类面为最优分类面。</p>
<p>2、<strong>LR对异常值敏感，SVM对异常值不敏感</strong>。</p>
<p>​   支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局。LR模型找到的那个超平面，是尽量让所有点都远离他，而SVM寻找的那个超平面，是只让最靠近中间分割线的那些点尽量远离，即只用到那些支持向量的样本。<br />
​   支持向量机改变非支持向量样本并不会引起决策面的变化。<br />
​   逻辑回归中改变任何样本都会引起决策面的变化。  </p>
<p>3、<strong>计算复杂度不同。对于海量数据，SVM的效率较低，LR效率比较高</strong></p>
<p>​   当样本较少，特征维数较低时，SVM和LR的运行时间均比较短，SVM较短一些。准确率的话，LR明显比SVM要高。当样本稍微增加些时，SVM运行时间开始增长，但是准确率赶超了LR。SVM时间虽长，但在可接受范围内。当数据量增长到20000时，特征维数增长到200时，SVM的运行时间剧烈增加，远远超过了LR的运行时间。但是准确率却和LR相差无几。(这其中主要原因是大量非支持向量参与计算，造成SVM的二次规划问题)</p>
<p>4、<strong>对非线性问题的处理方式不同</strong></p>
<p>​   LR主要靠特征构造，必须组合交叉特征，特征离散化。SVM也可以这样，还可以通过核函数kernel（因为只有支持向量参与核计算，计算复杂度不高）。由于可以利用核函数，SVM则可以通过对偶求解高效处理。LR则在特征空间维度很高时，表现较差。</p>
<p>5、<strong>SVM的损失函数就自带正则</strong>。<br />
​   损失函数中的&frac12;||w||^2项，这就是为什么SVM是结构风险最小化算法的原因！！！而LR必须另外在损失函数上添加正则项！！！**</p>
<p>6、SVM自带<strong>结构风险最小化</strong>，LR则是<strong>经验风险最小化</strong>。</p>
<p>7、SVM会用核函数而LR一般不用核函数。</p>
<h2 id="219">2.19 贝叶斯分类器<a class="headerlink" href="#219" title="Permanent link">&para;</a></h2>
<h3 id="2191">2.19.1 图解极大似然估计<a class="headerlink" href="#2191" title="Permanent link">&para;</a></h3>
<p>极大似然估计的原理，用一张图片来说明，如下图所示：</p>
<p><img alt="" src="../img/ch2/2.19.1.1.png" /></p>
<p>​   例：有两个外形完全相同的箱子，1号箱有99只白球，1只黑球；2号箱有1只白球，99只黑球。在一次实验中，取出的是黑球，请问是从哪个箱子中取出的？</p>
<p>​   一般的根据经验想法，会猜测这只黑球最像是从2号箱取出，此时描述的“最像”就有“最大似然”的意思，这种想法常称为“最大似然原理”。</p>
<h3 id="2192">2.19.2 极大似然估计原理<a class="headerlink" href="#2192" title="Permanent link">&para;</a></h3>
<p>​   总结起来，最大似然估计的目的就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。</p>
<p>​   极大似然估计是建立在极大似然原理的基础上的一个统计方法。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。</p>
<p>​   由于样本集中的样本都是独立同分布，可以只考虑一类样本集<span><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span>，来估计参数向量<span><span class="MathJax_Preview">\vec\theta</span><script type="math/tex">\vec\theta</script></span>。记已知的样本集为：
$$
D=\vec x_{1},\vec x_{2},...,\vec x_{n}
$$
似然函数（likelihood function）：联合概率密度函数<span><span class="MathJax_Preview">p(D|\vec\theta )</span><script type="math/tex">p(D|\vec\theta )</script></span>称为相对于<span><span class="MathJax_Preview">\vec x_{1},\vec x_{2},...,\vec x_{n}</span><script type="math/tex">\vec x_{1},\vec x_{2},...,\vec x_{n}</script></span>的<span><span class="MathJax_Preview">\vec\theta</span><script type="math/tex">\vec\theta</script></span>的似然函数。
$$
l(\vec\theta )=p(D|\vec\theta ) =p(\vec x_{1},\vec x_{2},...,\vec x_{n}|\vec\theta )=\prod_{i=1}^{n}p(\vec x_{i}|\vec \theta )
$$
如果<span><span class="MathJax_Preview">\hat{\vec\theta}</span><script type="math/tex">\hat{\vec\theta}</script></span>是参数空间中能使似然函数<span><span class="MathJax_Preview">l(\vec\theta)</span><script type="math/tex">l(\vec\theta)</script></span>最大的<span><span class="MathJax_Preview">\vec\theta</span><script type="math/tex">\vec\theta</script></span>值，则<span><span class="MathJax_Preview">\hat{\vec\theta}</span><script type="math/tex">\hat{\vec\theta}</script></span>应该是“最可能”的参数值，那么<span><span class="MathJax_Preview">\hat{\vec\theta}​</span><script type="math/tex">\hat{\vec\theta}​</script></span>就是<span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>的极大似然估计量。它是样本集的函数，记作：
$$
\hat{\vec\theta}=d(D)= \mathop {\arg \max}_{\vec\theta} l(\vec\theta )
$$
<span><span class="MathJax_Preview">\hat{\vec\theta}(\vec x_{1},\vec x_{2},...,\vec x_{n})</span><script type="math/tex">\hat{\vec\theta}(\vec x_{1},\vec x_{2},...,\vec x_{n})</script></span>称为极大似然函数估计值。</p>
<h3 id="2193">2.19.3 贝叶斯分类器基本原理<a class="headerlink" href="#2193" title="Permanent link">&para;</a></h3>
<p>​   贝叶斯决策论通过<strong>相关概率已知</strong>的情况下利用<strong>误判损失</strong>来选择最优的类别分类。<br />
假设有<span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>种可能的分类标记，记为<span><span class="MathJax_Preview">Y=\{c_1,c_2,...,c_N\}</span><script type="math/tex">Y=\{c_1,c_2,...,c_N\}</script></span>，那对于样本<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>，它属于哪一类呢？</p>
<p>计算步骤如下：</p>
<p>step 1. 算出样本<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>属于第i个类的概率，即<span><span class="MathJax_Preview">P(c_i|x)​</span><script type="math/tex">P(c_i|x)​</script></span>；</p>
<p>step 2. 通过比较所有的<span><span class="MathJax_Preview">P(c_i|\boldsymbol{x})</span><script type="math/tex">P(c_i|\boldsymbol{x})</script></span>，得到样本<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>所属的最佳类别。</p>
<p>step 3. 将类别<span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span>和样本<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>代入到贝叶斯公式中，得到：
$$
P(c_i|\boldsymbol{x})=\frac{P(\boldsymbol{x}|c_i)P(c_i)}{P(\boldsymbol{x})}.
$$
​   一般来说，<span><span class="MathJax_Preview">P(c_i)</span><script type="math/tex">P(c_i)</script></span>为先验概率，<span><span class="MathJax_Preview">P(\boldsymbol{x}|c_i)</span><script type="math/tex">P(\boldsymbol{x}|c_i)</script></span>为条件概率，<span><span class="MathJax_Preview">P(\boldsymbol{x})</span><script type="math/tex">P(\boldsymbol{x})</script></span>是用于归一化的证据因子。对于<span><span class="MathJax_Preview">P(c_i)</span><script type="math/tex">P(c_i)</script></span>可以通过训练样本中类别为<span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span>的样本所占的比例进行估计；此外，由于只需要找出最大的<span><span class="MathJax_Preview">P(\boldsymbol{x}|c_i)</span><script type="math/tex">P(\boldsymbol{x}|c_i)</script></span>，因此我们并不需要计算<span><span class="MathJax_Preview">P(\boldsymbol{x})</span><script type="math/tex">P(\boldsymbol{x})</script></span>。<br />
​   为了求解条件概率，基于不同假设提出了不同的方法，以下将介绍朴素贝叶斯分类器和半朴素贝叶斯分类器。</p>
<h3 id="2194">2.19.4 朴素贝叶斯分类器<a class="headerlink" href="#2194" title="Permanent link">&para;</a></h3>
<p>​   假设样本<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>包含<span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>个属性，即<span><span class="MathJax_Preview">\boldsymbol{x}=\{ x_1,x_2,...,x_d\}</span><script type="math/tex">\boldsymbol{x}=\{ x_1,x_2,...,x_d\}</script></span>。于是有：
$$
P(\boldsymbol{x}|c_i)=P(x_1,x_2,\cdots,x_d|c_i)
$$
这个联合概率难以从有限的训练样本中直接估计得到。于是，朴素贝叶斯（Naive Bayesian，简称NB）采用了“属性条件独立性假设”：对已知类别，假设所有属性相互独立。于是有：
$$
P(x_1,x_2,\cdots,x_d|c_i)=\prod_{j=1}^d P(x_j|c_i)
$$
这样的话，我们就可以很容易地推出相应的判定准则了：
$$
h_{nb}(\boldsymbol{x})=\mathop{\arg \max}<em>{c_i\in Y} P(c_i)\prod</em>{j=1}^dP(x_j|c_i)
$$
<strong>条件概率<span><span class="MathJax_Preview">P(x_j|c_i)​</span><script type="math/tex">P(x_j|c_i)​</script></span>的求解</strong></p>
<p>如果<span><span class="MathJax_Preview">x_j</span><script type="math/tex">x_j</script></span>是标签属性，那么我们可以通过计数的方法估计<span><span class="MathJax_Preview">P(x_j|c_i)</span><script type="math/tex">P(x_j|c_i)</script></span>
$$
P(x_j|c_i)=\frac{P(x_j,c_i)}{P(c_i)}\approx\frac{#(x_j,c_i)}{#(c_i)}
$$
其中，<span><span class="MathJax_Preview">\#(x_j,c_i)</span><script type="math/tex">\#(x_j,c_i)</script></span>表示在训练样本中<span><span class="MathJax_Preview">x_j</span><script type="math/tex">x_j</script></span>与<span><span class="MathJax_Preview">c_{i}</span><script type="math/tex">c_{i}</script></span>共同出现的次数。</p>
<p>如果<span><span class="MathJax_Preview">x_j​</span><script type="math/tex">x_j​</script></span>是数值属性，通常我们假设类别中<span><span class="MathJax_Preview">c_{i}​</span><script type="math/tex">c_{i}​</script></span>的所有样本第<span><span class="MathJax_Preview">j​</span><script type="math/tex">j​</script></span>个属性的值服从正态分布。我们首先估计这个分布的均值<span><span class="MathJax_Preview">μ​</span><script type="math/tex">μ​</script></span>和方差<span><span class="MathJax_Preview">σ​</span><script type="math/tex">σ​</script></span>，然后计算<span><span class="MathJax_Preview">x_j​</span><script type="math/tex">x_j​</script></span>在这个分布中的概率密度<span><span class="MathJax_Preview">P(x_j|c_i)​</span><script type="math/tex">P(x_j|c_i)​</script></span>。</p>
<h3 id="2195">2.19.5 举例理解朴素贝叶斯分类器<a class="headerlink" href="#2195" title="Permanent link">&para;</a></h3>
<p>使用经典的西瓜训练集如下：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">色泽</th>
<th align="center">根蒂</th>
<th align="center">敲声</th>
<th align="center">纹理</th>
<th align="center">脐部</th>
<th align="center">触感</th>
<th align="center">密度</th>
<th align="center">含糖率</th>
<th align="center">好瓜</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center">青绿</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.697</td>
<td align="center">0.460</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">乌黑</td>
<td align="center">蜷缩</td>
<td align="center">沉闷</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.774</td>
<td align="center">0.376</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">乌黑</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.634</td>
<td align="center">0.264</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">青绿</td>
<td align="center">蜷缩</td>
<td align="center">沉闷</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.608</td>
<td align="center">0.318</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">浅白</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.556</td>
<td align="center">0.215</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">青绿</td>
<td align="center">稍蜷</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">稍凹</td>
<td align="center">软粘</td>
<td align="center">0.403</td>
<td align="center">0.237</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">乌黑</td>
<td align="center">稍蜷</td>
<td align="center">浊响</td>
<td align="center">稍糊</td>
<td align="center">稍凹</td>
<td align="center">软粘</td>
<td align="center">0.481</td>
<td align="center">0.149</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">乌黑</td>
<td align="center">稍蜷</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">稍凹</td>
<td align="center">硬滑</td>
<td align="center">0.437</td>
<td align="center">0.211</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">乌黑</td>
<td align="center">稍蜷</td>
<td align="center">沉闷</td>
<td align="center">稍糊</td>
<td align="center">稍凹</td>
<td align="center">硬滑</td>
<td align="center">0.666</td>
<td align="center">0.091</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">青绿</td>
<td align="center">硬挺</td>
<td align="center">清脆</td>
<td align="center">清晰</td>
<td align="center">平坦</td>
<td align="center">软粘</td>
<td align="center">0.243</td>
<td align="center">0.267</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">浅白</td>
<td align="center">硬挺</td>
<td align="center">清脆</td>
<td align="center">模糊</td>
<td align="center">平坦</td>
<td align="center">硬滑</td>
<td align="center">0.245</td>
<td align="center">0.057</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">浅白</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">模糊</td>
<td align="center">平坦</td>
<td align="center">软粘</td>
<td align="center">0.343</td>
<td align="center">0.099</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">青绿</td>
<td align="center">稍蜷</td>
<td align="center">浊响</td>
<td align="center">稍糊</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.639</td>
<td align="center">0.161</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">浅白</td>
<td align="center">稍蜷</td>
<td align="center">沉闷</td>
<td align="center">稍糊</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.657</td>
<td align="center">0.198</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">乌黑</td>
<td align="center">稍蜷</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">稍凹</td>
<td align="center">软粘</td>
<td align="center">0.360</td>
<td align="center">0.370</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">浅白</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">模糊</td>
<td align="center">平坦</td>
<td align="center">硬滑</td>
<td align="center">0.593</td>
<td align="center">0.042</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">青绿</td>
<td align="center">蜷缩</td>
<td align="center">沉闷</td>
<td align="center">稍糊</td>
<td align="center">稍凹</td>
<td align="center">硬滑</td>
<td align="center">0.719</td>
<td align="center">0.103</td>
<td align="center">否</td>
</tr>
</tbody>
</table>
<p>对下面的测试例“测1”进行 分类：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">色泽</th>
<th align="center">根蒂</th>
<th align="center">敲声</th>
<th align="center">纹理</th>
<th align="center">脐部</th>
<th align="center">触感</th>
<th align="center">密度</th>
<th align="center">含糖率</th>
<th align="center">好瓜</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">测1</td>
<td align="center">青绿</td>
<td align="center">蜷缩</td>
<td align="center">浊响</td>
<td align="center">清晰</td>
<td align="center">凹陷</td>
<td align="center">硬滑</td>
<td align="center">0.697</td>
<td align="center">0.460</td>
<td align="center">？</td>
</tr>
</tbody>
</table>
<p>首先，估计类先验概率<span><span class="MathJax_Preview">P(c_j)</span><script type="math/tex">P(c_j)</script></span>，有
$$
\begin{align} 
&amp;P(好瓜=是)=\frac{8}{17}=0.471 \newline 
&amp;P(好瓜=否)=\frac{9}{17}=0.529 
\end{align}
$$
然后，为每个属性估计条件概率（这里，对于连续属性，假定它们服从正态分布）
$$
P_{青绿|是}=P（色泽=青绿|好瓜=是）=\frac{3}{8}=0.375
$$</p>
<div>
<div class="MathJax_Preview">
P_{青绿|否}=P（色泽=青绿|好瓜=否）=\frac{3}{9}\approx0.333
</div>
<script type="math/tex; mode=display">
P_{青绿|否}=P（色泽=青绿|好瓜=否）=\frac{3}{9}\approx0.333
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{蜷缩|是}=P（根蒂=蜷缩|好瓜=是）=\frac{5}{8}=0.625
</div>
<script type="math/tex; mode=display">
P_{蜷缩|是}=P（根蒂=蜷缩|好瓜=是）=\frac{5}{8}=0.625
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{蜷缩|否}=P（根蒂=蜷缩|好瓜=否）=\frac{3}{9}=0.333
</div>
<script type="math/tex; mode=display">
P_{蜷缩|否}=P（根蒂=蜷缩|好瓜=否）=\frac{3}{9}=0.333
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{浊响|是}=P（敲声=浊响|好瓜=是）=\frac{6}{8}=0.750
</div>
<script type="math/tex; mode=display">
P_{浊响|是}=P（敲声=浊响|好瓜=是）=\frac{6}{8}=0.750
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{浊响|否}=P（敲声=浊响|好瓜=否）=\frac{4}{9}\approx 0.444
</div>
<script type="math/tex; mode=display">
P_{浊响|否}=P（敲声=浊响|好瓜=否）=\frac{4}{9}\approx 0.444
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{清晰|是}=P（纹理=清晰|好瓜=是）=\frac{7}{8}= 0.875
</div>
<script type="math/tex; mode=display">
P_{清晰|是}=P（纹理=清晰|好瓜=是）=\frac{7}{8}= 0.875
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{清晰|否}=P（纹理=清晰|好瓜=否）=\frac{2}{9}\approx 0.222
</div>
<script type="math/tex; mode=display">
P_{清晰|否}=P（纹理=清晰|好瓜=否）=\frac{2}{9}\approx 0.222
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{凹陷|是}=P（脐部=凹陷|好瓜=是）=\frac{6}{8}= 0.750
</div>
<script type="math/tex; mode=display">
P_{凹陷|是}=P（脐部=凹陷|好瓜=是）=\frac{6}{8}= 0.750
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{凹陷|否}=P（脐部=凹陷|好瓜=否）=\frac{2}{9} \approx 0.222
</div>
<script type="math/tex; mode=display">
P_{凹陷|否}=P（脐部=凹陷|好瓜=否）=\frac{2}{9} \approx 0.222
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{硬滑|是}=P（触感=硬滑|好瓜=是）=\frac{6}{8}= 0.750
</div>
<script type="math/tex; mode=display">
P_{硬滑|是}=P（触感=硬滑|好瓜=是）=\frac{6}{8}= 0.750
</script>
</div>
<div>
<div class="MathJax_Preview">
P_{硬滑|否}=P（触感=硬滑|好瓜=否）=\frac{6}{9} \approx 0.667
</div>
<script type="math/tex; mode=display">
P_{硬滑|否}=P（触感=硬滑|好瓜=否）=\frac{6}{9} \approx 0.667
</script>
</div>
<div>
<div class="MathJax_Preview">
\begin{aligned}
\rho_{密度：0.697|是}&amp;=\rho（密度=0.697|好瓜=是）\\&amp;=\frac{1}{\sqrt{2 \pi}\times0.129}exp\left( -\frac{(0.697-0.574)^2}{2\times0.129^2}\right) \approx 1.959
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\rho_{密度：0.697|是}&=\rho（密度=0.697|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.129}exp\left( -\frac{(0.697-0.574)^2}{2\times0.129^2}\right) \approx 1.959
\end{aligned}
</script>
</div>
<div>
<div class="MathJax_Preview">
\begin{aligned}
\rho_{密度：0.697|否}&amp;=\rho（密度=0.697|好瓜=否）\\&amp;=\frac{1}{\sqrt{2 \pi}\times0.195}exp\left( -\frac{(0.697-0.496)^2}{2\times0.195^2}\right) \approx 1.203
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\rho_{密度：0.697|否}&=\rho（密度=0.697|好瓜=否）\\&=\frac{1}{\sqrt{2 \pi}\times0.195}exp\left( -\frac{(0.697-0.496)^2}{2\times0.195^2}\right) \approx 1.203
\end{aligned}
</script>
</div>
<div>
<div class="MathJax_Preview">
\begin{aligned}
\rho_{含糖：0.460|是}&amp;=\rho（密度=0.460|好瓜=是）\\&amp;=\frac{1}{\sqrt{2 \pi}\times0.101}exp\left( -\frac{(0.460-0.279)^2}{2\times0.101^2}\right) \approx 0.788
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\rho_{含糖：0.460|是}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.101}exp\left( -\frac{(0.460-0.279)^2}{2\times0.101^2}\right) \approx 0.788
\end{aligned}
</script>
</div>
<div>
<div class="MathJax_Preview">
\begin{aligned}
\rho_{含糖：0.460|否}&amp;=\rho（密度=0.460|好瓜=是）\\&amp;=\frac{1}{\sqrt{2 \pi}\times0.108}exp\left( -\frac{(0.460-0.154)^2}{2\times0.108^2}\right) \approx 0.066
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\rho_{含糖：0.460|否}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.108}exp\left( -\frac{(0.460-0.154)^2}{2\times0.108^2}\right) \approx 0.066
\end{aligned}
</script>
</div>
<p>于是有
$$
\begin{align} 
P(&amp;好瓜=是)\times P_{青绿|是} \times P_{蜷缩|是} \times P_{浊响|是} \times P_{清晰|是} \times P_{凹陷|是}\newline 
&amp;\times P_{硬滑|是} \times p_{密度：0.697|是} \times p_{含糖：0.460|是} \approx 0.063 \newline\newline 
P(&amp;好瓜=否)\times P_{青绿|否} \times P_{蜷缩|否} \times P_{浊响|否} \times P_{清晰|否} \times P_{凹陷|否}\newline 
&amp;\times P_{硬滑|否} \times p_{密度：0.697|否} \times p_{含糖：0.460|否} \approx 6.80\times 10^{-5} 
\end{align}
$$</p>
<p>由于<span><span class="MathJax_Preview">0.063&gt;6.80\times 10^{-5}</span><script type="math/tex">0.063>6.80\times 10^{-5}</script></span>，因此，朴素贝叶斯分类器将测试样本“测1”判别为“好瓜”。</p>
<h3 id="2196">2.19.6 半朴素贝叶斯分类器<a class="headerlink" href="#2196" title="Permanent link">&para;</a></h3>
<p>​   朴素贝叶斯采用了“属性条件独立性假设”，半朴素贝叶斯分类器的基本想法是适当考虑一部分属性间的相互依赖信息。<strong>独依赖估计</strong>（One-Dependence Estimator，简称ODE）是半朴素贝叶斯分类器最常用的一种策略。顾名思义，独依赖是假设每个属性在类别之外最多依赖一个其他属性，即：
$$
P(\boldsymbol{x}|c_i)=\prod_{j=1}^d P(x_j|c_i,{\rm pa}_j)
$$
其中<span><span class="MathJax_Preview">pa_j</span><script type="math/tex">pa_j</script></span>为属性<span><span class="MathJax_Preview">x_i</span><script type="math/tex">x_i</script></span>所依赖的属性，成为<span><span class="MathJax_Preview">x_i</span><script type="math/tex">x_i</script></span>的父属性。假设父属性<span><span class="MathJax_Preview">pa_j</span><script type="math/tex">pa_j</script></span>已知，那么可以使用下面的公式估计<span><span class="MathJax_Preview">P(x_j|c_i,{\rm pa}_j)</span><script type="math/tex">P(x_j|c_i,{\rm pa}_j)</script></span>
$$
P(x_j|c_i,{\rm pa}_j)=\frac{P(x_j,c_i,{\rm pa}_j)}{P(c_i,{\rm pa}_j)}
$$</p>
<h2 id="220-em">2.20 EM算法<a class="headerlink" href="#220-em" title="Permanent link">&para;</a></h2>
<h3 id="2201-em">2.20.1 EM算法基本思想<a class="headerlink" href="#2201-em" title="Permanent link">&para;</a></h3>
<p>​   最大期望算法（Expectation-Maximization algorithm, EM），是一类通过迭代进行极大似然估计的优化算法，通常作为牛顿迭代法的替代，用于对包含隐变量或缺失数据的概率模型进行参数估计。</p>
<p>​   最大期望算法基本思想是经过两个步骤交替进行计算：</p>
<p>​   第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值<strong>；</strong></p>
<p>​   第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。</p>
<p>​   M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。</p>
<h3 id="2202-em">2.20.2 EM算法推导<a class="headerlink" href="#2202-em" title="Permanent link">&para;</a></h3>
<p>​   对于<span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>个样本观察数据<span><span class="MathJax_Preview">x=(x^{1},x^{2},...,x^{m})</span><script type="math/tex">x=(x^{1},x^{2},...,x^{m})</script></span>，现在想找出样本的模型参数<span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>，其极大化模型分布的对数似然函数为：
$$
\theta = \mathop{\arg\max}<em>\theta\sum\limits</em>{i=1}^m logP(x^{(i)};\theta)
$$
如果得到的观察数据有未观察到的隐含数据<span><span class="MathJax_Preview">z=(z^{(1)},z^{(2)},...z^{(m)})</span><script type="math/tex">z=(z^{(1)},z^{(2)},...z^{(m)})</script></span>，极大化模型分布的对数似然函数则为：
$$
\theta =\mathop{\arg\max}<em>\theta\sum\limits</em>{i=1}^m logP(x<sup>{(i)};\theta) = \mathop{\arg\max}<em>\theta\sum\limits</em>{i=1}</sup>m log\sum\limits_{z<sup>{(i)}}P(x</sup>{(i)}, z^{(i)};\theta)  \tag{a}
$$
由于上式不能直接求出<span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>，采用缩放技巧：
$$
\begin{align} \sum\limits_{i=1}^m log\sum\limits_{z<sup>{(i)}}P(x</sup>{(i)}, z^{(i)};\theta)   &amp; = \sum\limits_{i=1}^m log\sum\limits_{z<sup>{(i)}}Q_i(z</sup>{(i)})\frac{P(x^{(i)}, z<sup>{(i)};\theta)}{Q_i(z</sup>{(i)})} \ &amp; \geqslant  \sum\limits_{i=1}^m \sum\limits_{z<sup>{(i)}}Q_i(z</sup>{(i)})log\frac{P(x^{(i)}, z<sup>{(i)};\theta)}{Q_i(z</sup>{(i)})} \end{align}   \tag{1}
$$
上式用到了Jensen不等式：
$$
log\sum\limits_j\lambda_jy_j \geqslant \sum\limits_j\lambda_jlogy_j\;\;,  \lambda_j \geqslant 0, \sum\limits_j\lambda_j =1
$$
并且引入了一个未知的新分布<span><span class="MathJax_Preview">Q_i(z^{(i)})</span><script type="math/tex">Q_i(z^{(i)})</script></span>。</p>
<p>此时，如果需要满足Jensen不等式中的等号，所以有：
$$
\frac{P(x^{(i)}, z<sup>{(i)};\theta)}{Q_i(z</sup>{(i)})} =c, c为常数
$$
由于<span><span class="MathJax_Preview">Q_i(z^{(i)})</span><script type="math/tex">Q_i(z^{(i)})</script></span>是一个分布，所以满足
$$
\sum\limits_{z}Q_i(z^{(i)}) =1
$$
综上，可得：
$$
Q_i(z^{(i)})  = \frac{P(x^{(i)}， z<sup>{(i)};\theta)}{\sum\limits_{z}P(x</sup>{(i)}, z^{(i)};\theta)} =  \frac{P(x^{(i)}, z<sup>{(i)};\theta)}{P(x</sup>{(i)};\theta)} = P( z<sup>{(i)}|x</sup>{(i)};\theta)
$$
如果<span><span class="MathJax_Preview">Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)};\theta)</span><script type="math/tex">Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)};\theta)</script></span> ，则第(1)式是我们的包含隐藏数据的对数似然的一个下界。如果我们能极大化这个下界，则也在尝试极大化我们的对数似然。即我们需要最大化下式：
$$
\mathop{\arg\max}<em>\theta \sum\limits</em>{i=1}^m \sum\limits_{z<sup>{(i)}}Q_i(z</sup>{(i)})log\frac{P(x^{(i)}， z<sup>{(i)};\theta)}{Q_i(z</sup>{(i)})}
$$
简化得：
$$
\mathop{\arg\max}<em>\theta \sum\limits</em>{i=1}^m \sum\limits_{z<sup>{(i)}}Q_i(z</sup>{(i)})log{P(x^{(i)}, z<sup>{(i)};\theta)}
$$
以上即为EM算法的M步，<span><span class="MathJax_Preview">\sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}​</span><script type="math/tex">\sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}​</script></span>可理解为$logP(x</sup>{(i)}, z^{(i)};\theta) <span><span class="MathJax_Preview">基于条件概率分布</span><script type="math/tex">基于条件概率分布</script></span>Q_i(z^{(i)}) $的期望。以上即为EM算法中E步和M步的具体数学含义。</p>
<h3 id="2203-em">2.20.3 图解EM算法<a class="headerlink" href="#2203-em" title="Permanent link">&para;</a></h3>
<p>​   考虑上一节中的（a）式，表达式中存在隐变量，直接找到参数估计比较困难，通过EM算法迭代求解下界的最大值到收敛为止。</p>
<p><img alt="" src="../img/ch2/2.20.1.jpg" /></p>
<p>​   图片中的紫色部分是我们的目标模型<span><span class="MathJax_Preview">p(x|\theta)</span><script type="math/tex">p(x|\theta)</script></span>，该模型复杂，难以求解析解，为了消除隐变量<span><span class="MathJax_Preview">z^{(i)}</span><script type="math/tex">z^{(i)}</script></span>的影响，我们可以选择一个不包含<span><span class="MathJax_Preview">z^{(i)}</span><script type="math/tex">z^{(i)}</script></span>的模型<span><span class="MathJax_Preview">r(x|\theta)</span><script type="math/tex">r(x|\theta)</script></span>，使其满足条件$r(x|\theta) \leqslant p(x|\theta) $。</p>
<p>求解步骤如下：</p>
<p>（1）选取<span><span class="MathJax_Preview">\theta_1</span><script type="math/tex">\theta_1</script></span>，使得<span><span class="MathJax_Preview">r(x|\theta_1) = p(x|\theta_1)</span><script type="math/tex">r(x|\theta_1) = p(x|\theta_1)</script></span>，然后对此时的<span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>求取最大值，得到极值点<span><span class="MathJax_Preview">\theta_2</span><script type="math/tex">\theta_2</script></span>，实现参数的更新。</p>
<p>（2）重复以上过程到收敛为止，在更新过程中始终满足$r \leqslant p $.</p>
<h3 id="2204-em">2.20.4 EM算法流程<a class="headerlink" href="#2204-em" title="Permanent link">&para;</a></h3>
<p>输入：观察数据<span><span class="MathJax_Preview">x=(x^{(1)},x^{(2)},...x^{(m)})</span><script type="math/tex">x=(x^{(1)},x^{(2)},...x^{(m)})</script></span>，联合分布<span><span class="MathJax_Preview">p(x,z ;\theta)</span><script type="math/tex">p(x,z ;\theta)</script></span>，条件分布<span><span class="MathJax_Preview">p(z|x; \theta)</span><script type="math/tex">p(z|x; \theta)</script></span>，最大迭代次数<span><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span></p>
<p>1）随机初始化模型参数<span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>的初值<span><span class="MathJax_Preview">\theta^0</span><script type="math/tex">\theta^0</script></span>。</p>
<p>2）<span><span class="MathJax_Preview">for \ j  \ from \ 1  \ to  \ j</span><script type="math/tex">for \ j  \ from \ 1  \ to  \ j</script></span>：</p>
<p>​   a） E步。计算联合分布的条件概率期望：
$$
Q_i(z^{(i)}) = P( z<sup>{(i)}|x</sup>{(i)}, \theta^{j})
$$</p>
<div>
<div class="MathJax_Preview">
L(\theta, \theta^{j}) = \sum\limits_{i=1}^m\sum\limits_{z^{(i)}}P( z^{(i)}|x^{(i)}, \theta^{j})log{P(x^{(i)}, z^{(i)};\theta)}
</div>
<script type="math/tex; mode=display">
L(\theta, \theta^{j}) = \sum\limits_{i=1}^m\sum\limits_{z^{(i)}}P( z^{(i)}|x^{(i)}, \theta^{j})log{P(x^{(i)}, z^{(i)};\theta)}
</script>
</div>
<p>​   b） M步。极大化<span><span class="MathJax_Preview">L(\theta, \theta^{j})</span><script type="math/tex">L(\theta, \theta^{j})</script></span>，得到<span><span class="MathJax_Preview">\theta^{j+1}</span><script type="math/tex">\theta^{j+1}</script></span>:
$$
\theta^{j+1} = \mathop{\arg\max}_\theta L(\theta, \theta^{j})
$$
​   c） 如果<span><span class="MathJax_Preview">\theta^{j+1}</span><script type="math/tex">\theta^{j+1}</script></span>收敛，则算法结束。否则继续回到步骤a）进行E步迭代。</p>
<p>输出：模型参数<span><span class="MathJax_Preview">\theta​</span><script type="math/tex">\theta​</script></span>。</p>
<h2 id="221">2.21 降维和聚类<a class="headerlink" href="#221" title="Permanent link">&para;</a></h2>
<h3 id="2211">2.21.1 图解为什么会产生“维数灾难”？<a class="headerlink" href="#2211" title="Permanent link">&para;</a></h3>
<p>​   假如数据集包含10张照片，照片中包含三角形和圆两种形状。现在来设计一个分类器进行训练，让这个分类器对其他的照片进行正确分类（假设三角形和圆的总数是无限大），简单的，我们用一个特征进行分类：</p>
<p><img alt="" src="../img/ch2/2.21.1.1.png" /></p>
<p>​                                           图2.21.1.a</p>
<p>​   从上图可看到，如果仅仅只有一个特征进行分类，三角形和圆几乎是均匀分布在这条线段上，很难将10张照片线性分类。那么，增加一个特征后的情况会怎么样：</p>
<p><img alt="" src="../img/ch2/2.21.1.2.png" /></p>
<p>​                                           图2.21.1.b</p>
<p>增加一个特征后，我们发现仍然无法找到一条直线将猫和狗分开。所以，考虑需要再增加一个特征：</p>
<p><img alt="" src="../img/ch2/2.21.1.3.png" /></p>
<p>​                                           图2.21.1.c</p>
<p><img alt="" src="../img/ch2/2.21.1.4.png" /></p>
<p>​                                           图2.21.1.d</p>
<p>​   此时，可以找到一个平面将三角形和圆分开。</p>
<p>​   现在计算一下不同特征数是样本的密度：</p>
<p>​   （1）一个特征时，假设特征空间时长度为5的线段，则样本密度为<span><span class="MathJax_Preview">10 \div 5 = 2</span><script type="math/tex">10 \div 5 = 2</script></span>。</p>
<p>​   （2）两个特征时，特征空间大小为$ 5\times5 = 25<span><span class="MathJax_Preview">，样本密度为</span><script type="math/tex">，样本密度为</script></span>10 \div 25 = 0.4$。</p>
<p>​   （3）三个特征时，特征空间大小是$ 5\times5\times5 = 125<span><span class="MathJax_Preview">，样本密度为</span><script type="math/tex">，样本密度为</script></span>10 \div 125 = 0.08$。</p>
<p>​   以此类推，如果继续增加特征数量，样本密度会越来越稀疏，此时，更容易找到一个超平面将训练样本分开。当特征数量增长至无限大时，样本密度就变得非常稀疏。</p>
<p>​   下面看一下将高维空间的分类结果映射到低维空间时，会出现什么情况？</p>
<p><img alt="" src="../img/ch2/2.21.1.5.png" /></p>
<p>​                                       图2.21.1.e</p>
<p>​   上图是将三维特征空间映射到二维特征空间后的结果。尽管在高维特征空间时训练样本线性可分，但是映射到低维空间后，结果正好相反。事实上，增加特征数量使得高维空间线性可分，相当于在低维空间内训练一个复杂的非线性分类器。不过，这个非线性分类器太过“聪明”，仅仅学到了一些特例。如果将其用来辨别那些未曾出现在训练样本中的测试样本时，通常结果不太理想，会造成过拟合问题。</p>
<p><img alt="" src="../img/ch2/2.21.1.6a.png" /></p>
<p>​                                       图2.21.1.f</p>
<p>​   上图所示的只采用2个特征的线性分类器分错了一些训练样本，准确率似乎没有图2.21.1.e的高，但是，采用2个特征的线性分类器的泛化能力比采用3个特征的线性分类器要强。因为，采用2个特征的线性分类器学习到的不只是特例，而是一个整体趋势，对于那些未曾出现过的样本也可以比较好地辨别开来。换句话说，通过减少特征数量，可以避免出现过拟合问题，从而避免“维数灾难”。</p>
<p><img alt="" src="../img/ch2/2.21.1.6.png" /></p>
<p>​   上图从另一个角度诠释了“维数灾难”。假设只有一个特征时，特征的值域是0到1，每一个三角形和圆的特征值都是唯一的。如果我们希望训练样本覆盖特征值值域的20%，那么就需要三角形和圆总数的20%。我们增加一个特征后，为了继续覆盖特征值值域的20%就需要三角形和圆总数的45%(<span><span class="MathJax_Preview">0.452^2\approx0.2</span><script type="math/tex">0.452^2\approx0.2</script></span>)。继续增加一个特征后，需要三角形和圆总数的58%(<span><span class="MathJax_Preview">0.583^3\approx0.2</span><script type="math/tex">0.583^3\approx0.2</script></span>)。随着特征数量的增加，为了覆盖特征值值域的20%，就需要更多的训练样本。如果没有足够的训练样本，就可能会出现过拟合问题。</p>
<p>​   通过上述例子，我们可以看到特征数量越多，训练样本就会越稀疏，分类器的参数估计就会越不准确，更加容易出现过拟合问题。“维数灾难”的另一个影响是训练样本的稀疏性并不是均匀分布的。处于中心位置的训练样本比四周的训练样本更加稀疏。</p>
<p><img alt="" src="../img/ch2/2.21.1.7.png" /></p>
<p>​   假设有一个二维特征空间，如上图所示的矩形，在矩形内部有一个内切的圆形。由于越接近圆心的样本越稀疏，因此，相比于圆形内的样本，那些位于矩形四角的样本更加难以分类。当维数变大时，特征超空间的容量不变，但单位圆的容量会趋于0，在高维空间中，大多数训练数据驻留在特征超空间的角落。散落在角落的数据要比处于中心的数据难于分类。</p>
<h3 id="2212">2.21.2 怎样避免维数灾难<a class="headerlink" href="#2212" title="Permanent link">&para;</a></h3>
<p><strong>有待完善！！！</strong></p>
<p>解决维度灾难问题：</p>
<p>主成分分析法PCA，线性判别法LDA</p>
<p>奇异值分解简化数据、拉普拉斯特征映射</p>
<p>Lassio缩减系数法、小波分析法、</p>
<h3 id="2213">2.21.3 聚类和降维有什么区别与联系？<a class="headerlink" href="#2213" title="Permanent link">&para;</a></h3>
<p>​   聚类用于找寻数据内在的分布结构，既可以作为一个单独的过程，比如异常检测等等。也可作为分类等其他学习任务的前驱过程。聚类是标准的无监督学习。</p>
<p>​   1）在一些推荐系统中需确定新用户的类型，但定义“用户类型”却可能不太容易，此时往往可先对原有的用户数据进行聚类，根据聚类结果将每个簇定义为一个类,然后再基于这些类训练分类模型,用于判别新用户的类型。</p>
<p><img alt="" src="../img/ch2/2.21.3.1.png" /></p>
<p>​   2）而降维则是为了缓解维数灾难的一个重要方法，就是通过某种数学变换将原始高维属性空间转变为一个低维“子空间”。其基于的假设就是，虽然人们平时观测到的数据样本虽然是高维的，但是实际上真正与学习任务相关的是个低维度的分布。从而通过最主要的几个特征维度就可以实现对数据的描述，对于后续的分类很有帮助。比如对于Kaggle（数据分析竞赛平台之一）上的泰坦尼克号生还问题。通过给定一个乘客的许多特征如年龄、姓名、性别、票价等，来判断其是否能在海难中生还。这就需要首先进行特征筛选，从而能够找出主要的特征，让学习到的模型有更好的泛化性。</p>
<p>​   聚类和降维都可以作为分类等问题的预处理步骤。</p>
<p><img alt="" src="../img/ch2/2-19.jpg" /></p>
<p>​   但是他们虽然都能实现对数据的约减。但是二者适用的对象不同，聚类针对的是数据点，而降维则是对于数据的特征。另外它们有着很多种实现方法。聚类中常用的有K-means、层次聚类、基于密度的聚类等；降维中常用的则PCA、Isomap、LLE等。</p>
<h3 id="2214">2.21.4 有哪些聚类算法优劣衡量标准<a class="headerlink" href="#2214" title="Permanent link">&para;</a></h3>
<p>不同聚类算法有不同的优劣和不同的适用条件。可从以下方面进行衡量判断：
    1、算法的处理能力：处理大的数据集的能力，即算法复杂度；处理数据噪声的能力；处理任意形状，包括有间隙的嵌套的数据的能力； 
    2、算法是否需要预设条件：是否需要预先知道聚类个数，是否需要用户给出领域知识； </p>
<p>​    3、算法的数据输入属性：算法处理的结果与数据输入的顺序是否相关，也就是说算法是否独立于数据输入顺序；算法处理有很多属性数据的能力，也就是对数据维数是否敏感，对数据的类型有无要求。</p>
<h3 id="2215">2.21.5 聚类和分类有什么区别？<a class="headerlink" href="#2215" title="Permanent link">&para;</a></h3>
<p><strong>聚类（Clustering） </strong>
    聚类，简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起。一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，因此聚类通常并不需要使用训练数据进行学习，在机器学习中属于无监督学习。 </p>
<p><strong>分类（Classification） </strong></p>
<p>​     分类，对于一个分类器，通常需要你告诉它“这个东西被分为某某类”。一般情况下，一个分类器会从它得到的训练集中进行学习，从而具备对未知数据进行分类的能力，在机器学习中属于监督学习。</p>
<h3 id="2216">2.21.6 不同聚类算法特点性能比较<a class="headerlink" href="#2216" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">算法名称</th>
<th align="center">可伸缩性</th>
<th align="center">适合的数据类型</th>
<th align="center">高维性</th>
<th align="center">异常数据抗干扰性</th>
<th align="center">聚类形状</th>
<th align="center">算法效率</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">WAVECLUSTER</td>
<td align="center">很高</td>
<td align="center">数值型</td>
<td align="center">很高</td>
<td align="center">较高</td>
<td align="center">任意形状</td>
<td align="center">很高</td>
</tr>
<tr>
<td align="center">ROCK</td>
<td align="center">很高</td>
<td align="center">混合型</td>
<td align="center">很高</td>
<td align="center">很高</td>
<td align="center">任意形状</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">BIRCH</td>
<td align="center">较高</td>
<td align="center">数值型</td>
<td align="center">较低</td>
<td align="center">较低</td>
<td align="center">球形</td>
<td align="center">很高</td>
</tr>
<tr>
<td align="center">CURE</td>
<td align="center">较高</td>
<td align="center">数值型</td>
<td align="center">一般</td>
<td align="center">很高</td>
<td align="center">任意形状</td>
<td align="center">较高</td>
</tr>
<tr>
<td align="center">K-PROTOTYPES</td>
<td align="center">一般</td>
<td align="center">混合型</td>
<td align="center">较低</td>
<td align="center">较低</td>
<td align="center">任意形状</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">DENCLUE</td>
<td align="center">较低</td>
<td align="center">数值型</td>
<td align="center">较高</td>
<td align="center">一般</td>
<td align="center">任意形状</td>
<td align="center">较高</td>
</tr>
<tr>
<td align="center">OPTIGRID</td>
<td align="center">一般</td>
<td align="center">数值型</td>
<td align="center">较高</td>
<td align="center">一般</td>
<td align="center">任意形状</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">CLIQUE</td>
<td align="center">较高</td>
<td align="center">数值型</td>
<td align="center">较高</td>
<td align="center">较高</td>
<td align="center">任意形状</td>
<td align="center">较低</td>
</tr>
<tr>
<td align="center">DBSCAN</td>
<td align="center">一般</td>
<td align="center">数值型</td>
<td align="center">较低</td>
<td align="center">较高</td>
<td align="center">任意形状</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">CLARANS</td>
<td align="center">较低</td>
<td align="center">数值型</td>
<td align="center">较低</td>
<td align="center">较高</td>
<td align="center">球形</td>
<td align="center">较低</td>
</tr>
</tbody>
</table>
<h3 id="2217">2.21.7 四种常用聚类方法之比较<a class="headerlink" href="#2217" title="Permanent link">&para;</a></h3>
<p>​   聚类就是按照某个特定标准把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。即聚类后同一类的数据尽可能聚集到一起，不同类数据尽量分离。
​   主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。下面主要对k-means聚类算法、凝聚型层次聚类算法、神经网络聚类算法之SOM,以及模糊聚类的FCM算法通过通用测试数据集进行聚类效果的比较和分析。</p>
<h3 id="2218-k-means">2.21.8 k-means聚类算法<a class="headerlink" href="#2218-k-means" title="Permanent link">&para;</a></h3>
<p>k-means是划分方法中较经典的聚类算法之一。由于该算法的效率高，所以在对大规模数据进行聚类时被广泛应用。目前，许多算法均围绕着该算法进行扩展和改进。
k-means算法以k为参数，把n个对象分成k个簇，使簇内具有较高的相似度，而簇间的相似度较低。k-means算法的处理过程如下：首先，随机地 选择k个对象，每个对象初始地代表了一个簇的平均值或中心;对剩余的每个对象，根据其与各簇中心的距离，将它赋给最近的簇;然后重新计算每个簇的平均值。 这个过程不断重复，直到准则函数收敛。通常，采用平方误差准则，其定义如下：
$$
E=\sum_{i=1}^{k}\sum_{p\in C_i}\left|p-m_i\right|^2
$$
　这里E是数据中所有对象的平方误差的总和，p是空间中的点，<span><span class="MathJax_Preview">m_i</span><script type="math/tex">m_i</script></span>是簇<span><span class="MathJax_Preview">C_i</span><script type="math/tex">C_i</script></span>的平均值[9]。该目标函数使生成的簇尽可能紧凑独立，使用的距离度量是欧几里得距离，当然也可以用其他距离度量。</p>
<p><strong>算法流程</strong>：
​    输入：包含n个对象的数据和簇的数目k；
​    输出：n个对象到k个簇，使平方误差准则最小。
​    步骤：
　　(1) 任意选择k个对象作为初始的簇中心；
　　(2) 根据簇中对象的平均值，将每个对象(重新)赋予最类似的簇；
　　(3) 更新簇的平均值，即计算每个簇中对象的平均值；
　　(4) 重复步骤(2)、(3)直到簇中心不再变化；</p>
<h3 id="2219">2.21.9 层次聚类算法<a class="headerlink" href="#2219" title="Permanent link">&para;</a></h3>
<p>​    根据层次分解的顺序是自底向上的还是自上向下的，层次聚类算法分为凝聚的层次聚类算法和分裂的层次聚类算法。
　凝聚型层次聚类的策略是先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，直到所有对象都在一个簇中，或者某个终结条件被满足。绝大多数层次聚类属于凝聚型层次聚类，它们只是在簇间相似度的定义上有所不同。</p>
<p><strong>算法流程</strong>：</p>
<p>注：以采用最小距离的凝聚层次聚类算法为例：</p>
<p>(1) 将每个对象看作一类，计算两两之间的最小距离；
　(2) 将距离最小的两个类合并成一个新类；
　(3) 重新计算新类与所有类之间的距离；
　(4) 重复(2)、(3)，直到所有类最后合并成一类。</p>
<h3 id="22110-som">2.21.10 SOM聚类算法<a class="headerlink" href="#22110-som" title="Permanent link">&para;</a></h3>
<p>​   SOM神经网络[11]是由芬兰神经网络专家Kohonen教授提出的，该算法假设在输入对象中存在一些拓扑结构或顺序，可以实现从输入空间(n维)到输出平面(2维)的降维映射，其映射具有拓扑特征保持性质,与实际的大脑处理有很强的理论联系。</p>
<p>​   SOM网络包含输入层和输出层。输入层对应一个高维的输入向量，输出层由一系列组织在2维网格上的有序节点构成，输入节点与输出节点通过权重向量连接。 学习过程中，找到与之距离最短的输出层单元，即获胜单元，对其更新。同时，将邻近区域的权值更新，使输出节点保持输入向量的拓扑特征。</p>
<p><strong>算法流程</strong>：</p>
<p>​   (1) 网络初始化，对输出层每个节点权重赋初值；
​   (2) 从输入样本中随机选取输入向量并且归一化，找到与输入向量距离最小的权重向量；
​   (3) 定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢；
​   (4) 提供新样本、进行训练；
​   (5) 收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果。</p>
<h3 id="22111-fcm">2.21.11 FCM聚类算法<a class="headerlink" href="#22111-fcm" title="Permanent link">&para;</a></h3>
<p>​   1965年美国加州大学柏克莱分校的扎德教授第一次提出了‘集合’的概念。经过十多年的发展，模糊集合理论渐渐被应用到各个实际应用方面。为克服非此即彼的分类缺点，出现了以模糊集合论为数学基础的聚类分析。用模糊数学的方法进行聚类分析，就是模糊聚类分析[12]。<br />
​   FCM算法是一种以隶属度来确定每个数据点属于某个聚类程度的算法。该聚类算法是传统硬聚类算法的一种改进。<br />
​   设数据集<span><span class="MathJax_Preview">X={x_1,x_2,...,x_n}</span><script type="math/tex">X={x_1,x_2,...,x_n}</script></span>,它的模糊<span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>划分可用模糊矩阵<span><span class="MathJax_Preview">U=[u_{ij}]</span><script type="math/tex">U=[u_{ij}]</script></span>表示，矩阵<span><span class="MathJax_Preview">U</span><script type="math/tex">U</script></span>的元素<span><span class="MathJax_Preview">u_{ij}</span><script type="math/tex">u_{ij}</script></span>表示第<span><span class="MathJax_Preview">j(j=1,2,...,n)</span><script type="math/tex">j(j=1,2,...,n)</script></span>个数据点属于第<span><span class="MathJax_Preview">i(i=1,2,...,c)</span><script type="math/tex">i(i=1,2,...,c)</script></span>类的隶属度，<span><span class="MathJax_Preview">u_{ij}</span><script type="math/tex">u_{ij}</script></span>满足如下条件：<br />
$$
\begin{equation}
\left{
\begin{array}{lr}
\sum_{i=1}^c u_{ij}=1 \quad\forall~j
\u_{ij}\in[0,1] \quad\forall ~i,j
\\sum_{j=1}^c u_{ij}&gt;0 \quad\forall ~i
\end{array}
\right.
\end{equation}
$$
目前被广泛使用的聚类准则是取类内加权误差平方和的极小值。即：
$$
(min)J_m(U,V)=\sum<sup>n_{j=1}\sum</sup>c_{i=1}u<sup>m_{ij}d</sup>2_{ij}(x_j,v_i)
$$
其中<span><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>为聚类中心，<span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>为加权指数，<span><span class="MathJax_Preview">d_{ij}(x_j,v_i)=||v_i-x_j||</span><script type="math/tex">d_{ij}(x_j,v_i)=||v_i-x_j||</script></span>。</p>
<p><strong>算法流程</strong>：</p>
<p>(1) 标准化数据矩阵；
　(2) 建立模糊相似矩阵，初始化隶属矩阵；
　(3) 算法开始迭代，直到目标函数收敛到极小值；
　(4) 根据迭代结果，由最后的隶属矩阵确定数据所属的类，显示最后的聚类结果。</p>
<h3 id="22112">2.21.12 四种聚类算法试验<a class="headerlink" href="#22112" title="Permanent link">&para;</a></h3>
<p>​   选取专门用于测试分类、聚类算法的国际通用的UCI数据库中的IRIS数据集，IRIS数据集包含150个样本数据，分别取自三种不同 的莺尾属植物setosa、versicolor和virginica的花朵样本,每个数据含有4个属性，即萼片长度、萼片宽度、花瓣长度、花瓣宽度，单位为cm。 在数据集上执行不同的聚类算法，可以得到不同精度的聚类结果。基于前面描述的各算法原理及流程，可初步得如下聚类结果。</p>
<table>
<thead>
<tr>
<th>聚类方法</th>
<th>聚错样本数</th>
<th>运行时间/s</th>
<th>平均准确率/（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>K-means</td>
<td>17</td>
<td>0.146001</td>
<td>89</td>
</tr>
<tr>
<td>层次聚类</td>
<td>51</td>
<td>0.128744</td>
<td>66</td>
</tr>
<tr>
<td>SOM</td>
<td>22</td>
<td>5.267283</td>
<td>86</td>
</tr>
<tr>
<td>FCM</td>
<td>12</td>
<td>0.470417</td>
<td>92</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：</p>
<p>(1) 聚错样本数：总的聚错的样本数，即各类中聚错的样本数的和；<br />
(2) 运行时间：即聚类整个过程所耗费的时间，单位为s；<br />
(3) 平均准确度：设原数据集有k个类,用<span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span>表示第i类，<span><span class="MathJax_Preview">n_i</span><script type="math/tex">n_i</script></span>为<span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span>中样本的个数，<span><span class="MathJax_Preview">m_i</span><script type="math/tex">m_i</script></span>为聚类正确的个数,则<span><span class="MathJax_Preview">m_i/n_i</span><script type="math/tex">m_i/n_i</script></span>为 第i类中的精度，则平均精度为：<span><span class="MathJax_Preview">avg=\frac{1}{k}\sum_{i=1}^{k}\frac{m_{i}}{n_{i}}</span><script type="math/tex">avg=\frac{1}{k}\sum_{i=1}^{k}\frac{m_{i}}{n_{i}}</script></span>。  </p>
<h2 id="222-gbdt">2.22 GBDT和随机森林的区别<a class="headerlink" href="#222-gbdt" title="Permanent link">&para;</a></h2>
<p>GBDT和随机森林的相同点：
1、都是由多棵树组成
2、最终的结果都是由多棵树一起决定</p>
<p>GBDT和随机森林的不同点：
1、组成随机森林的树可以是分类树，也可以是回归树；而GBDT只由回归树组成
2、组成随机森林的树可以并行生成；而GBDT只能是串行生成
3、对于最终的输出结果而言，随机森林采用多数投票等；而GBDT则是将所有结果累加起来，或者加权累加起来
4、随机森林对异常值不敏感，GBDT对异常值非常敏感
5、随机森林对训练集一视同仁，GBDT是基于权值的弱分类器的集成
6、随机森林是通过减少模型方差提高性能，GBDT是通过减少模型偏差提高性能</p>
<h2 id="223-one-hot-encodeing">2.23 理解 One Hot Encodeing 原理及作用？<a class="headerlink" href="#223-one-hot-encodeing" title="Permanent link">&para;</a></h2>
<p>问题由来：</p>
<p>​   在很多<strong>机器学习</strong>任务中，特征并不总是连续值，而有可能是分类值。</p>
<p>例如，考虑一下的三个特征：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>[&quot;male&quot;, &quot;female&quot;] [&quot;from Europe&quot;, &quot;from US&quot;, &quot;from Asia&quot;]
[&quot;uses Firefox&quot;, &quot;uses Chrome&quot;, &quot;uses Safari&quot;, &quot;uses Internet Explorer&quot;]
</pre></div>
</td></tr></table>

<p>如果将上述特征用数字表示，效率会高很多。例如：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>[&quot;male&quot;, &quot;from US&quot;, &quot;uses Internet Explorer&quot;] 表示为 [0, 1, 3]
[&quot;female&quot;, &quot;from Asia&quot;, &quot;uses Chrome&quot;] 表示为 [1, 2, 1]
</pre></div>
</td></tr></table>

<p>​   但是，即使转化为数字表示后，上述数据也不能直接用在我们的分类器中。因为，分类器往往默认数据数据是连续的（可以计算距离？），并且是有序的（而上面这个 0 并不是说比 1 要高级）。但是，按照我们上述的表示，数字并不是有序的，而是随机分配的。</p>
<p><strong>独热编码</strong></p>
<p>​   为了解决上述问题，其中一种可能的解决方法是采用独热编码（One-Hot Encoding）。独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对 N 个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。</p>
<p>例如：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>自然状态码为：000,001,010,011,100,101
独热编码为：000001,000010,000100,001000,010000,100000
</pre></div>
</td></tr></table>

<p>​   可以这样理解，对于每一个特征，如果它有 m 个可能值，那么经过独热编码后，就变成了 m 个二元特征（如成绩这个特征有好，中，差变成 one-hot 就是 100, 010, 001）。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。</p>
<p>这样做的好处主要有：</p>
<ol>
<li>解决了分类器不好处理属性数据的问题；</li>
<li>在一定程度上也起到了扩充特征的作用。</li>
</ol>
<h2 id="224">2.24 大数据与深度学习之间的关系<a class="headerlink" href="#224" title="Permanent link">&para;</a></h2>
<p><strong>大数据</strong>通常被定义为“超出常用软件工具捕获，管理和处理能力”的数据集。 
<strong>机器学习</strong>关心的问题是如何构建计算机程序使用经验自动改进。
<strong>数据挖掘</strong>是从数据中提取模式的特定算法的应用。
在数据挖掘中，重点在于算法的应用，而不是算法本身。</p>
<p><strong>机器学习和数据挖掘</strong>之间的关系如下：
数据挖掘是一个过程，在此过程中机器学习算法被用作提取数据集中的潜在有价值模式的工具。
大数据与深度学习关系总结如下：</p>
<ol>
<li>深度学习是一种模拟大脑的行为。可以从所学习对象的机制以及行为等等很多相关联的方面进行学习，模仿类型行为以及思维。</li>
<li>深度学习对于大数据的发展有帮助。深度学习对于大数据技术开发的每一个阶段均有帮助，不管是数据的分析还是挖掘还是建模，只有深度学习，这些工作才会有可能一一得到实现。</li>
<li>深度学习转变了解决问题的思维。很多时候发现问题到解决问题，走一步看一步不是一个主要的解决问题的方式了，在深度学习的基础上，要求我们从开始到最后都要基于一个目标，为了需要优化的那个最终目标去进行处理数据以及将数据放入到数据应用平台上去，这就是端到端（End to End）。</li>
<li>大数据的深度学习需要一个框架。在大数据方面的深度学习都是从基础的角度出发的，深度学习需要一个框架或者一个系统。总而言之，将你的大数据通过深度分析变为现实，这就是深度学习和大数据的最直接关系。</li>
</ol>
<h2 id="_2">参考文献<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>[1]   Goodfellow I, Bengio Y, Courville A. Deep learning[M]. MIT press, 2016.<br />
[2]   周志华. 机器学习[M].清华大学出版社, 2016.<br />
[3]   Michael A. Nielsen. "Neural Networks and Deep Learning", Determination Press, 2015.<br />
[4]   Suryansh S. Gradient Descent: All You Need to Know, 2018.<br />
[5]   刘建平. 梯度下降小结,EM算法的推导, 2018<br />
[6]   杨小兵．聚类分析中若干关键技术的研究[D]． 杭州：浙江大学, 2005.<br />
[7]   XU Rui, Donald Wunsch 1 1． survey of clustering algorithm[J]．IEEE．Transactions on Neural Networks, 2005, 16(3)：645-67 8.<br />
[8]   YI Hong, SAM K． Learning assignment order of instances for the constrained k-means clustering algorithm[J]．IEEE Transactions on Systems, Man, and Cybernetics, Part B：Cybernetics,2009,39 (2)：568-574.<br />
[9]   贺玲, 吴玲达, 蔡益朝．数据挖掘中的聚类算法综述[J]．计算机应用研究, 2007, 24(1):10-13．<br />
[10]  孙吉贵, 刘杰, 赵连宇．聚类算法研究[J]．软件学报, 2008, 19(1)：48-61．<br />
[11]  孔英会, 苑津莎, 张铁峰等．基于数据流管理技术的配变负荷分类方法研究．中国国际供电会议, CICED2006．<br />
[12]  马晓艳, 唐雁．层次聚类算法研究[J]．计算机科学, 2008, 34(7)：34-36．<br />
[13]  FISHER R A． Iris Plants Database <a href="https://www.ics.uci.edu/vmlearn/MLRepository.html">https://www.ics.uci.edu/vmlearn/MLRepository.html</a>, Authorized license．<br />
[14]  Quinlan J R. Induction of decision trees[J]. Machine learning, 1986, 1(1): 81-106.<br />
[15]  Breiman L. Random forests[J]. Machine learning, 2001, 45(1): 5-32.  </p>
                
                  
                
              
              
                


  <h2 id="__comments">评论</h2>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = "https://hai5g.cn/aiwiki/qa500/ch02_机器学习基础/第二章_机器学习基础/";
      this.page.identifier =
        "/qa500/ch02_机器学习基础/第二章_机器学习基础/";
    };
    (function() {
      var d = document, s = d.createElement("script");
      s.src = "//AI-Wiki.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../ch01_math/ch01_math/" title="第一章_数学基础" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  后退
                </span>
                第一章_数学基础
              </span>
            </div>
          </a>
        
        
          <a href="../../ch03_深度学习基础/第三章_深度学习基础/" title="第三章_深度学习基础" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前进
                </span>
                第三章_深度学习基础
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2019 AI Wiki Team
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/application.39abc4af.js"></script>
      
        
        
          
          <script src="../../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../../.."}})</script>
      
        <script src="https://cdn.jsdelivr.net/gh/ethantw/Han@3.3.0/dist/han.min.js"></script>
      
        <script src="../../../_static/js/extra.js?v=10"></script>
      
        <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>